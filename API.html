

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>rampy API &mdash; RamPy 0.6.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8fa8b3e9"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Utilities" href="utils.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            RamPy
              <img src="_static/Rampy.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="philosophy.html">Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="news.html">Rampy News</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="firststeps.html">First Steps</a></li>
<li class="toctree-l1"><a class="reference internal" href="preprocessing.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="baseline.html">Baseline</a></li>
<li class="toctree-l1"><a class="reference internal" href="smoothing.html">Smoothing and filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="signalparams.html">Signal parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="peakfitting.html">Peak fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="machinelearning.html">Machine learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="maps.html">Maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="dac.html">Diamond Anvil Cell Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Example notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utilities</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">rampy API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.baseline">rampy.baseline module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.als_baseline"><code class="docutils literal notranslate"><span class="pre">als_baseline()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.arPLS_baseline"><code class="docutils literal notranslate"><span class="pre">arPLS_baseline()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.baseline"><code class="docutils literal notranslate"><span class="pre">baseline()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.drPLS_baseline"><code class="docutils literal notranslate"><span class="pre">drPLS_baseline()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.extract_signal"><code class="docutils literal notranslate"><span class="pre">extract_signal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.fit_baseline"><code class="docutils literal notranslate"><span class="pre">fit_baseline()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.get_portion_interest"><code class="docutils literal notranslate"><span class="pre">get_portion_interest()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.rubberband_baseline"><code class="docutils literal notranslate"><span class="pre">rubberband_baseline()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.standardize_data"><code class="docutils literal notranslate"><span class="pre">standardize_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.validate_input"><code class="docutils literal notranslate"><span class="pre">validate_input()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.baseline.validate_roi"><code class="docutils literal notranslate"><span class="pre">validate_roi()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.filters">rampy.filters module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.filters.smooth"><code class="docutils literal notranslate"><span class="pre">smooth()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.filters.spectrafilter"><code class="docutils literal notranslate"><span class="pre">spectrafilter()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.filters.whittaker"><code class="docutils literal notranslate"><span class="pre">whittaker()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.plotting">rampy.plotting module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.plotting.plot_spectrum"><code class="docutils literal notranslate"><span class="pre">plot_spectrum()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.functions">rampy.functions module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.constant"><code class="docutils literal notranslate"><span class="pre">constant()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.difffull"><code class="docutils literal notranslate"><span class="pre">difffull()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.diffshort"><code class="docutils literal notranslate"><span class="pre">diffshort()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.funexp"><code class="docutils literal notranslate"><span class="pre">funexp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.funlog"><code class="docutils literal notranslate"><span class="pre">funlog()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.gauss_lsq"><code class="docutils literal notranslate"><span class="pre">gauss_lsq()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.gauss_lsq_lfix"><code class="docutils literal notranslate"><span class="pre">gauss_lsq_lfix()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.linear"><code class="docutils literal notranslate"><span class="pre">linear()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.linear0"><code class="docutils literal notranslate"><span class="pre">linear0()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.multigaussian"><code class="docutils literal notranslate"><span class="pre">multigaussian()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.functions.poly2"><code class="docutils literal notranslate"><span class="pre">poly2()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.maps">rampy.maps module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.maps.maps"><code class="docutils literal notranslate"><span class="pre">maps</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rampy.maps.maps.area"><code class="docutils literal notranslate"><span class="pre">maps.area()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.maps.maps.area_ratio"><code class="docutils literal notranslate"><span class="pre">maps.area_ratio()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.maps.maps.background"><code class="docutils literal notranslate"><span class="pre">maps.background()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.maps.maps.centroid"><code class="docutils literal notranslate"><span class="pre">maps.centroid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.maps.maps.intensity"><code class="docutils literal notranslate"><span class="pre">maps.intensity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.maps.maps.intensity_ratio"><code class="docutils literal notranslate"><span class="pre">maps.intensity_ratio()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.maps.maps.normalise"><code class="docutils literal notranslate"><span class="pre">maps.normalise()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.maps.maps.smooth"><code class="docutils literal notranslate"><span class="pre">maps.smooth()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.maps.peak"><code class="docutils literal notranslate"><span class="pre">peak()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.maps.read_horiba"><code class="docutils literal notranslate"><span class="pre">read_horiba()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.maps.read_renishaw"><code class="docutils literal notranslate"><span class="pre">read_renishaw()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.mixing">rampy.mixing module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.mixing.mixing_sp"><code class="docutils literal notranslate"><span class="pre">mixing_sp()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.ml_classification">rampy.ml_classification module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.ml_classification.mlclassificator"><code class="docutils literal notranslate"><span class="pre">mlclassificator</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.x"><code class="docutils literal notranslate"><span class="pre">mlclassificator.x</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.y"><code class="docutils literal notranslate"><span class="pre">mlclassificator.y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.X_test"><code class="docutils literal notranslate"><span class="pre">mlclassificator.X_test</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.y_test"><code class="docutils literal notranslate"><span class="pre">mlclassificator.y_test</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.algorithm"><code class="docutils literal notranslate"><span class="pre">mlclassificator.algorithm</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.scaling"><code class="docutils literal notranslate"><span class="pre">mlclassificator.scaling</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.scaler"><code class="docutils literal notranslate"><span class="pre">mlclassificator.scaler</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.test_size"><code class="docutils literal notranslate"><span class="pre">mlclassificator.test_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.rand_state"><code class="docutils literal notranslate"><span class="pre">mlclassificator.rand_state</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.params_"><code class="docutils literal notranslate"><span class="pre">mlclassificator.params_</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.model"><code class="docutils literal notranslate"><span class="pre">mlclassificator.model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.X_scaler"><code class="docutils literal notranslate"><span class="pre">mlclassificator.X_scaler</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.fit"><code class="docutils literal notranslate"><span class="pre">mlclassificator.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.predict"><code class="docutils literal notranslate"><span class="pre">mlclassificator.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.refit"><code class="docutils literal notranslate"><span class="pre">mlclassificator.refit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_classification.mlclassificator.scale_data"><code class="docutils literal notranslate"><span class="pre">mlclassificator.scale_data()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.ml_exploration">rampy.ml_exploration module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer"><code class="docutils literal notranslate"><span class="pre">mlexplorer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.x"><code class="docutils literal notranslate"><span class="pre">mlexplorer.x</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.X_test"><code class="docutils literal notranslate"><span class="pre">mlexplorer.X_test</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.algorithm"><code class="docutils literal notranslate"><span class="pre">mlexplorer.algorithm</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.scaling"><code class="docutils literal notranslate"><span class="pre">mlexplorer.scaling</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.scaler"><code class="docutils literal notranslate"><span class="pre">mlexplorer.scaler</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.test_size"><code class="docutils literal notranslate"><span class="pre">mlexplorer.test_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.rand_state"><code class="docutils literal notranslate"><span class="pre">mlexplorer.rand_state</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.model"><code class="docutils literal notranslate"><span class="pre">mlexplorer.model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.Remarks"><code class="docutils literal notranslate"><span class="pre">mlexplorer.Remarks</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.http"><code class="docutils literal notranslate"><span class="pre">mlexplorer.http</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.fit"><code class="docutils literal notranslate"><span class="pre">mlexplorer.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.predict"><code class="docutils literal notranslate"><span class="pre">mlexplorer.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_exploration.mlexplorer.refit"><code class="docutils literal notranslate"><span class="pre">mlexplorer.refit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.ml_regressor">rampy.ml_regressor module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.ml_regressor.chemical_splitting"><code class="docutils literal notranslate"><span class="pre">chemical_splitting()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.ml_regressor.mlregressor"><code class="docutils literal notranslate"><span class="pre">mlregressor</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.x"><code class="docutils literal notranslate"><span class="pre">mlregressor.x</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.y"><code class="docutils literal notranslate"><span class="pre">mlregressor.y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.X_test"><code class="docutils literal notranslate"><span class="pre">mlregressor.X_test</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.y_test"><code class="docutils literal notranslate"><span class="pre">mlregressor.y_test</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.algorithm"><code class="docutils literal notranslate"><span class="pre">mlregressor.algorithm</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.scaling"><code class="docutils literal notranslate"><span class="pre">mlregressor.scaling</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.scaler"><code class="docutils literal notranslate"><span class="pre">mlregressor.scaler</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.test_size"><code class="docutils literal notranslate"><span class="pre">mlregressor.test_size</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.rand_state"><code class="docutils literal notranslate"><span class="pre">mlregressor.rand_state</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.param_kr"><code class="docutils literal notranslate"><span class="pre">mlregressor.param_kr</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.param_svm"><code class="docutils literal notranslate"><span class="pre">mlregressor.param_svm</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.param_neurons"><code class="docutils literal notranslate"><span class="pre">mlregressor.param_neurons</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.param_bagging"><code class="docutils literal notranslate"><span class="pre">mlregressor.param_bagging</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.prediction_train"><code class="docutils literal notranslate"><span class="pre">mlregressor.prediction_train</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.prediction_test"><code class="docutils literal notranslate"><span class="pre">mlregressor.prediction_test</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.model"><code class="docutils literal notranslate"><span class="pre">mlregressor.model</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.X_scaler"><code class="docutils literal notranslate"><span class="pre">mlregressor.X_scaler</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.Y_scaler"><code class="docutils literal notranslate"><span class="pre">mlregressor.Y_scaler</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.fit"><code class="docutils literal notranslate"><span class="pre">mlregressor.fit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.predict"><code class="docutils literal notranslate"><span class="pre">mlregressor.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.ml_regressor.mlregressor.refit"><code class="docutils literal notranslate"><span class="pre">mlregressor.refit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.peak_area">rampy.peak_area module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.peak_area.area_peak"><code class="docutils literal notranslate"><span class="pre">area_peak()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.peak_area.gaussianarea"><code class="docutils literal notranslate"><span class="pre">gaussianarea()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.peak_area.peakarea"><code class="docutils literal notranslate"><span class="pre">peakarea()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.peak_shapes">rampy.peak_shapes module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.peak_shapes.gaussian"><code class="docutils literal notranslate"><span class="pre">gaussian()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.peak_shapes.lorentzian"><code class="docutils literal notranslate"><span class="pre">lorentzian()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.peak_shapes.pearson7"><code class="docutils literal notranslate"><span class="pre">pearson7()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.peak_shapes.pseudovoigt"><code class="docutils literal notranslate"><span class="pre">pseudovoigt()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.rameau">rampy.rameau module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.rameau.DG2017_calibrate"><code class="docutils literal notranslate"><span class="pre">DG2017_calibrate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.rameau.DG2017_predict"><code class="docutils literal notranslate"><span class="pre">DG2017_predict()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.rameau.LL2012_calibrate"><code class="docutils literal notranslate"><span class="pre">LL2012_calibrate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.rameau.LL2012_predict"><code class="docutils literal notranslate"><span class="pre">LL2012_predict()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.rameau.fit_spectra"><code class="docutils literal notranslate"><span class="pre">fit_spectra()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.rameau.rameau"><code class="docutils literal notranslate"><span class="pre">rameau</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.x"><code class="docutils literal notranslate"><span class="pre">rameau.x</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.y"><code class="docutils literal notranslate"><span class="pre">rameau.y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.y_corr"><code class="docutils literal notranslate"><span class="pre">rameau.y_corr</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.y_base"><code class="docutils literal notranslate"><span class="pre">rameau.y_base</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.rws"><code class="docutils literal notranslate"><span class="pre">rameau.rws</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.rw"><code class="docutils literal notranslate"><span class="pre">rameau.rw</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.rs"><code class="docutils literal notranslate"><span class="pre">rameau.rs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.water"><code class="docutils literal notranslate"><span class="pre">rameau.water</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.water_predicted"><code class="docutils literal notranslate"><span class="pre">rameau.water_predicted</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.p"><code class="docutils literal notranslate"><span class="pre">rameau.p</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.names"><code class="docutils literal notranslate"><span class="pre">rameau.names</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.calibrate"><code class="docutils literal notranslate"><span class="pre">rameau.calibrate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.data_reduction"><code class="docutils literal notranslate"><span class="pre">rameau.data_reduction()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.external_calibration"><code class="docutils literal notranslate"><span class="pre">rameau.external_calibration()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">rameau.names</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3"><code class="docutils literal notranslate"><span class="pre">rameau.p</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rampy.rameau.rameau.predict"><code class="docutils literal notranslate"><span class="pre">rameau.predict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4"><code class="docutils literal notranslate"><span class="pre">rameau.rs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5"><code class="docutils literal notranslate"><span class="pre">rameau.rw</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6"><code class="docutils literal notranslate"><span class="pre">rameau.rws</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7"><code class="docutils literal notranslate"><span class="pre">rameau.water</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8"><code class="docutils literal notranslate"><span class="pre">rameau.water_predicted</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9"><code class="docutils literal notranslate"><span class="pre">rameau.x</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10"><code class="docutils literal notranslate"><span class="pre">rameau.y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11"><code class="docutils literal notranslate"><span class="pre">rameau.y_base</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12"><code class="docutils literal notranslate"><span class="pre">rameau.y_corr</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.spectranization">rampy.spectranization module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.centroid"><code class="docutils literal notranslate"><span class="pre">centroid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.convert_x_units"><code class="docutils literal notranslate"><span class="pre">convert_x_units()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.despiking"><code class="docutils literal notranslate"><span class="pre">despiking()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.flipsp"><code class="docutils literal notranslate"><span class="pre">flipsp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.invcm_to_nm"><code class="docutils literal notranslate"><span class="pre">invcm_to_nm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.nm_to_invcm"><code class="docutils literal notranslate"><span class="pre">nm_to_invcm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.normalise"><code class="docutils literal notranslate"><span class="pre">normalise()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.resample"><code class="docutils literal notranslate"><span class="pre">resample()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.shiftsp"><code class="docutils literal notranslate"><span class="pre">shiftsp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.spectraoffset"><code class="docutils literal notranslate"><span class="pre">spectraoffset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.spectrarray"><code class="docutils literal notranslate"><span class="pre">spectrarray()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#rampy.spectranization.spectrataux"><code class="docutils literal notranslate"><span class="pre">spectrataux()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-rampy.tlcorrection">rampy.tlcorrection module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rampy.tlcorrection.tlcorrection"><code class="docutils literal notranslate"><span class="pre">tlcorrection()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">RamPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">rampy API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/API.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="rampy-api">
<h1>rampy API<a class="headerlink" href="#rampy-api" title="Link to this heading"></a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-rampy.baseline">
<span id="rampy-baseline-module"></span><h2>rampy.baseline module<a class="headerlink" href="#module-rampy.baseline" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.als_baseline">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">als_baseline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.baseline.als_baseline" title="Link to this definition"></a></dt>
<dd><p>Asymmetric Least Squares baseline fitting.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.arPLS_baseline">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">arPLS_baseline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.baseline.arPLS_baseline" title="Link to this definition"></a></dt>
<dd><p>Asymmetrically Reweighted Penalized Least Squares baseline fitting.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.baseline">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">baseline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'poly'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#rampy.baseline.baseline" title="Link to this definition"></a></dt>
<dd><p>Subtracts a baseline from an x-y spectrum using various methods.</p>
<p>This function performs baseline subtraction on spectroscopic data by fitting a model
to the background signal. It supports multiple correction methods, including polynomial
fitting, splines, and advanced penalized least squares techniques.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_input</strong> (<em>ndarray</em>) – The x-axis values (e.g., wavelength or wavenumber).</p></li>
<li><p><strong>y_input</strong> (<em>ndarray</em>) – The y-axis values (e.g., intensity or absorbance).</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>The method used for baseline fitting. Default is “poly”.
Available options:</p>
<blockquote>
<div><ul>
<li><p>”poly”: Polynomial fitting. Requires <cite>polynomial_order</cite>.</p></li>
<li><p>”unispline”: Spline fitting using Scipy’s <cite>UnivariateSpline</cite>. Requires <cite>s</cite>.</p></li>
<li><p>”gcvspline”: Spline fitting using GCVSpline. Requires <cite>s</cite> and optionally <cite>ese_y</cite>.</p></li>
<li><p>”gaussian”: Gaussian function fitting. Requires <cite>p0_gaussian</cite>.</p></li>
<li><p>”exp”: Exponential background fitting. Requires <cite>p0_exp</cite>.</p></li>
<li><p>”log”: Logarithmic background fitting. Requires <cite>p0_log</cite>.</p></li>
<li><p>”rubberband”: Rubberband correction using convex hull interpolation.</p></li>
<li><p>”als”: Asymmetric Least Squares correction. Requires <cite>lam</cite>, <cite>p</cite>, and <cite>niter</cite>.</p></li>
<li><p>”arPLS”: Asymmetrically Reweighted Penalized Least Squares smoothing. Requires <cite>lam</cite> and <cite>ratio</cite>.</p></li>
<li><p>”drPLS”: Doubly Reweighted Penalized Least Squares smoothing. Requires <cite>niter</cite>, <cite>lam</cite>, <cite>eta</cite>, and <cite>ratio</cite>.</p></li>
<li><p>”whittaker”: Whittaker smoothing with weights applied to regions of interest. Requires <cite>lam</cite>.</p></li>
<li><p>”GP”: Gaussian process method using a rational quadratic kernel.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional parameters specific to the chosen method.
- roi (ndarray): Regions of interest for baseline fitting. Default is the entire range of <cite>x_input</cite>.
- polynomial_order (int): Degree of the polynomial for the “poly” method. Default is 1.
- s (float): Spline smoothing coefficient for “unispline” and “gcvspline”. Default is 2.0.
- ese_y (ndarray): Errors associated with y_input for the “gcvspline” method.</p>
<blockquote>
<div><p>Defaults to sqrt(abs(y_input)) if not provided.</p>
</div></blockquote>
<ul>
<li><p>lam (float): Smoothness parameter for methods like “als”, “arPLS”, and others. Default is 1e5.</p></li>
<li><p>p (float): Weighting parameter for ALS method. Recommended values are between 0.001 and 0.1. Default is 0.01.</p></li>
<li><p>ratio (float): Convergence ratio parameter for arPLS/drPLS methods. Default is 0.01 for arPLS and 0.001 for drPLS.</p></li>
<li><p>niter (int): Number of iterations for ALS/drPLS methods. Defaults are 10 for ALS and 100 for drPLS.</p></li>
<li><p>eta (float): Roughness parameter for drPLS method, between 0 and 1. Default is 0.5.</p></li>
<li><p>p0_gaussian (list): Initial parameters [a, b, c] for Gaussian fitting:
(y = a cdot exp(-log(2) cdot ((x-b)/c)^2)). Default is [1., 1., 1.].</p></li>
<li><p>p0_exp (list): Initial parameters [a, b, c] for exponential fitting:
(y = a cdot exp(b cdot (x-c))). Default is [1., 1., 0.].</p></li>
<li><p>p0_log (list): Initial parameters [a, b, c, d] for logarithmic fitting:
(y = a cdot log(-b cdot (x-c)) - d cdot x^2). Default is [1., 1., 1., 1.].</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>corrected_signal (ndarray): The signal after baseline subtraction.
baseline_fitted (ndarray): The fitted baseline.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the specified method is not recognized or invalid parameters are provided.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The input data is standardized before fitting to improve numerical stability during optimization.
The fitted baseline is transformed back to the original scale before subtraction.</p>
<p class="rubric">Examples</p>
<p>Example with polynomial baseline correction:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="n">nb_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">nb_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">50</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">250.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">peak</span> <span class="o">+</span> <span class="n">background</span> <span class="o">+</span> <span class="n">noise</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">500</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corrected_signal</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;poly&quot;</span><span class="p">,</span> <span class="n">roi</span> <span class="o">=</span> <span class="n">roi</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Example with GCVSpline algorithm:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">corrected_signal</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;gcvspline&quot;</span><span class="p">,</span> <span class="n">roi</span><span class="o">=</span><span class="n">roi</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Example with Whittaker smoothing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">corrected_signal</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;whittaker&quot;</span><span class="p">,</span> <span class="n">roi</span><span class="o">=</span><span class="n">roi</span><span class="p">)</span>
</pre></div>
</div>
<p>Example with Gaussian process:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">corrected_signal</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;GP&quot;</span><span class="p">,</span> <span class="n">roi</span><span class="o">=</span><span class="n">roi</span><span class="p">)</span>
</pre></div>
</div>
<p>Example with rubberband correction:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">corrected_signal</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;rubberband&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Example with ALS algorithm:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">corrected_signal</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;als&quot;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.drPLS_baseline">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">drPLS_baseline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.baseline.drPLS_baseline" title="Link to this definition"></a></dt>
<dd><p>Doubly Reweighted Penalized Least Squares baseline fitting.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.extract_signal">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">extract_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.baseline.extract_signal" title="Link to this definition"></a></dt>
<dd><p>Extracts the signal from specified regions of interest (ROI) in the x-y data.</p>
<p>This function selects and extracts portions of the input x-y data based on the
specified regions of interest (ROI) provided in <cite>roi</cite>. Each region is defined
by a lower and upper bound along the x-axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x-axis values (e.g., time, wavelength, or other independent variables).</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y-axis values corresponding to the x-axis values (e.g., signal intensity).</p></li>
<li><p><strong>roi</strong> (<em>ndarray</em><em> or </em><em>list</em><em> of </em><em>lists</em>) – <p>Regions of interest (ROI) where the signal should be extracted.
Must be an n x 2 array or a list of lists, where <cite>n</cite> is the number of regions to extract.
Each sublist or row should contain two elements:</p>
<blockquote>
<div><ul>
<li><p>The lower bound of the region (inclusive).</p></li>
<li><p>The upper bound of the region (inclusive).</p></li>
</ul>
</div></blockquote>
<p class="rubric">Example</p>
<ul>
<li><p>Array: <cite>np.array([[10, 20], [50, 70]])</cite></p></li>
<li><p>List: <cite>[[10, 20], [50, 70]]</cite></p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A 2-column array containing the extracted x-y signals from the specified regions.</dt><dd><p>The first column contains the x values, and the second column contains the corresponding y values.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>roi</cite> is not a valid n x 2 array or list of lists, or if any region in <cite>roi</cite>
    falls outside the range of <cite>x</cite>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Overlapping regions in <cite>roi</cite> are not merged; they are processed as separate regions.</p></li>
<li><p>If no valid regions are found within <cite>roi</cite>, an empty array is returned.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Extracting signal from two regions in an x-y dataset:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roi</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">70</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extracted_signal</span> <span class="o">=</span> <span class="n">extract_signal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">roi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">extracted_signal</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.fit_baseline">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">fit_baseline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yafit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.baseline.fit_baseline" title="Link to this definition"></a></dt>
<dd><p>Fit the baseline using the specified method.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.get_portion_interest">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">get_portion_interest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.baseline.get_portion_interest" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.rubberband_baseline">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">rubberband_baseline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.baseline.rubberband_baseline" title="Link to this definition"></a></dt>
<dd><p>Perform rubberband baseline correction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The x-axis values.</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – The y values corresponding to x.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>baseline_fitted</strong> – The fitted baseline.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the convex hull does not have enough points for interpolation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.standardize_data">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">standardize_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.baseline.standardize_data" title="Link to this definition"></a></dt>
<dd><p>Standardize the data using sklearn’s StandardScaler.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.validate_input">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">validate_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.baseline.validate_input" title="Link to this definition"></a></dt>
<dd><p>Validate the input arrays.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.baseline.validate_roi">
<span class="sig-prename descclassname"><span class="pre">rampy.baseline.</span></span><span class="sig-name descname"><span class="pre">validate_roi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.baseline.validate_roi" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-rampy.filters">
<span id="rampy-filters-module"></span><h2>rampy.filters module<a class="headerlink" href="#module-rampy.filters" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.filters.smooth">
<span class="sig-prename descclassname"><span class="pre">rampy.filters.</span></span><span class="sig-name descname"><span class="pre">smooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'whittaker'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.filters.smooth" title="Link to this definition"></a></dt>
<dd><p>Smooths the provided signal using various smoothing algorithms.</p>
<p>This function applies different smoothing techniques to the input signal,
including Whittaker smoothing, Savitzky-Golay filtering, spline-based methods,
and window-based filters. Each method is designed to reduce noise while preserving
signal features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – The x-axis values (e.g., time or wavelength). For window-based methods,
these values should be equally spaced.</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em>) – <p>The y-axis values to be smoothed.
method (str): The smoothing method to apply. Default is “whittaker”.</p>
<blockquote>
<div><dl class="simple">
<dt>Available options:</dt><dd><ul>
<li><p>”whittaker”: Whittaker smoother (Eilers 2003).</p></li>
<li><p>”savgol”: Savitzky-Golay filter.</p></li>
<li><p>”GCVSmoothedNSpline”: Spline with generalized cross-validation.</p></li>
<li><p>”MSESmoothedNSpline”: Spline with mean squared error criterion
(requires the gcvspline library).</p></li>
<li><p>”DOFSmoothedNSpline”: Spline with degrees of freedom criterion
(requires the gcvspline library).</p></li>
<li><p>”flat”: Moving average window.</p></li>
<li><p>”hanning”, “hamming”, “bartlett”, “blackman”: Various window filters.</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional parameters specific to the chosen method.
- window_length (int): Length of the filter window for window-based methods</p>
<blockquote>
<div><p>and Savitzky-Golay filter. Must be a positive odd integer. Default is 5.</p>
</div></blockquote>
<ul>
<li><p>polyorder (int): Polynomial order for Savitzky-Golay filter. Must be less
than <cite>window_length</cite>. Default is 2.</p></li>
<li><p>Lambda (float): Smoothing parameter for the Whittaker filter. Higher values
produce smoother fits. Default is (10^5).</p></li>
<li><p>d (int): Difference order in the Whittaker filter. Default is 2.</p></li>
<li><p>ese_y (float or np.ndarray): Errors associated with y values for spline methods.
Default is 1.0.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The smoothed signal sampled on <cite>x</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If the input vector is smaller than the window size or if an invalid
    smoothing method is specified.</p></li>
<li><p><strong>ImportError</strong> – If <cite>gcvspline</cite> is not installed when using MSESmoothedNSpline or DOFSmoothedNSpline.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The “whittaker” method implements the perfect smoother described by Eilers (2003).</p></li>
<li><p>The “savgol” method uses <cite>scipy.signal.savgol_filter()</cite>.</p></li>
<li><p>Spline methods require <cite>scipy &gt;= 1.10.0</cite> or the <cite>gcvspline</cite> package.</p></li>
<li><p>Window-based methods are implemented following the SciPy Cookbook.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Smooth a noisy signal using Savitzky-Golay filtering:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smoothed_signal</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;savgol&quot;</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply Whittaker smoothing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">smoothed_signal</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;whittaker&quot;</span><span class="p">,</span> <span class="n">Lambda</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a moving average window:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">smoothed_signal</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;flat&quot;</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.filters.spectrafilter">
<span class="sig-prename descclassname"><span class="pre">rampy.filters.</span></span><span class="sig-name descname"><span class="pre">spectrafilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectre</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filtertype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fq</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numtaps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">columns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.filters.spectrafilter" title="Link to this definition"></a></dt>
<dd><p>Applies a Butterworth filter to specific columns of spectral data.</p>
<p>This function filters specific frequencies in the provided spectral data using a Butterworth filter.
It supports low-pass, high-pass, band-pass, and band-stop filtering. The input spectra must be
provided as an array where the first column represents the x-axis (e.g., wavelength or time),
and subsequent columns represent the y-axis values of multiple spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spectre</strong> (<em>np.ndarray</em>) – A 2D array of spectral data. The first column contains x-axis values
(e.g., time or wavelength), and subsequent columns contain y-axis values for multiple spectra.</p></li>
<li><p><strong>filtertype</strong> (<em>str</em>) – The type of filter to apply. Choose from:
- ‘low’: Low-pass filter.
- ‘high’: High-pass filter.
- ‘bandpass’: Band-pass filter.
- ‘bandstop’: Band-stop filter.</p></li>
<li><p><strong>fq</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – The cutoff frequency/frequencies for the filter. For ‘low’ or ‘high’ filters,
this is a single float value. For ‘bandpass’ or ‘bandstop’, this must be a sequence of two values
<cite>[low_cutoff, high_cutoff]</cite>.</p></li>
<li><p><strong>numtaps</strong> (<em>int</em>) – The order of the Butterworth filter. Higher values result in sharper transitions but may
introduce more ringing artifacts.</p></li>
<li><p><strong>columns</strong> (<em>np.ndarray</em>) – An array specifying which columns in the input <cite>spectre</cite> to apply the filter to.
Each value should correspond to a valid column index.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D array with the same shape as <cite>spectre</cite>, where the specified columns have been filtered.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If an invalid <cite>filtertype</cite> is provided or if <cite>fq</cite> is improperly specified for ‘bandpass’ or
    ‘bandstop’ filters.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The x-axis values (first column) are copied directly to the output without modification.</p></li>
<li><p>The cutoff frequencies (<cite>fq</cite>) are normalized based on the Nyquist frequency, which is calculated from
the sampling rate inferred from the x-axis spacing.</p></li>
<li><p>The Butterworth filter is applied using zero-phase filtering (<cite>scipy.signal.filtfilt</cite>) to avoid phase distortion.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Apply a low-pass filter to a single spectrum:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># Time axis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>  <span class="c1"># Signal with two frequencies</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_spectre</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">spectrafilter</span><span class="p">(</span><span class="n">spectre</span><span class="p">,</span> <span class="n">filtertype</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fq</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">numtaps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>Apply a band-pass filter to multiple spectra:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spectre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span>  <span class="c1"># Two spectra</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_spectre</span> <span class="o">=</span> <span class="n">spectrafilter</span><span class="p">(</span><span class="n">spectre</span><span class="p">,</span> <span class="n">filtertype</span><span class="o">=</span><span class="s1">&#39;bandpass&#39;</span><span class="p">,</span> <span class="n">fq</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="n">numtaps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Butterworth Filter Design: <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html</a></p></li>
<li><p>Zero-Phase Filtering: <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.filtfilt.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.filtfilt.html</a></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.filters.whittaker">
<span class="sig-prename descclassname"><span class="pre">rampy.filters.</span></span><span class="sig-name descname"><span class="pre">whittaker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.filters.whittaker" title="Link to this definition"></a></dt>
<dd><p>Smooths a signal using the Whittaker smoother.</p>
<p>This function applies Whittaker smoothing to reduce noise in a signal while preserving
its features. It uses penalized least squares optimization with a specified smoothing
coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>np.ndarray</em>) – An array containing the values to smooth. The data should be equally spaced.</p></li>
<li><p><strong>weights</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Weights for the signal. Regions with weight 0 will not</p></li>
<li><p><strong>points.</strong> (<em>be smoothed. Default is uniform weights across all</em>)</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional parameters for Whittaker smoothing.
- Lambda (float): The smoothing coefficient; higher values produce smoother results.</p>
<blockquote>
<div><p>Default is (10^5).</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array containing the smoothed values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>y</cite> or <cite>weights</cite> are invalid.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This implementation follows the description provided by Eilers (2003).</p></li>
</ul>
<p class="rubric">References</p>
<p>Eilers, P.H.C., 2003. A Perfect Smoother. Anal. Chem. 75, 3631–3636.</p>
<p class="rubric">Examples</p>
<p>Smooth a noisy signal using default weights and Lambda:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smoothed_signal</span> <span class="o">=</span> <span class="n">whittaker</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply custom weights and Lambda:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span><span class="p">[</span><span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Do not smooth this region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smoothed_signal</span> <span class="o">=</span> <span class="n">whittaker</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">Lambda</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-rampy.plotting">
<span id="rampy-plotting-module"></span><h2>rampy.plotting module<a class="headerlink" href="#module-rampy.plotting" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.plotting.plot_spectrum">
<span class="sig-prename descclassname"><span class="pre">rampy.plotting.</span></span><span class="sig-name descname"><span class="pre">plot_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baselines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baseline_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothed_signals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothed_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Spectrum'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xaxis_title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yaxis_title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.plotting.plot_spectrum" title="Link to this definition"></a></dt>
<dd><p>Plots a spectrum with optional baselines, smoothed signals, and regions of interest (bir) using Plotly.</p>
<p>This function adds a single spectrum to a Plotly figure. It supports overlaying baselines, smoothed signals,
and highlighting regions of interest (bir). If no figure is provided, a new Plotly figure is created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like</em>) – The x-axis values for the spectrum.</p></li>
<li><p><strong>y</strong> (<em>array-like</em>) – The y-axis values for the spectrum.</p></li>
<li><p><strong>fig</strong> (<em>plotly.graph_objects.Figure</em><em>, </em><em>optional</em>) – The Plotly figure to which the spectrum will be added.
If None, a new figure will be created. Default is None.</p></li>
<li><p><strong>baselines</strong> (<em>list</em><em> of </em><em>array-like</em><em>, </em><em>optional</em>) – List of baseline arrays to overlay on the spectrum. Default is None.</p></li>
<li><p><strong>baseline_labels</strong> (<em>list</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – Labels for each baseline. Default is None.</p></li>
<li><p><strong>smoothed_signals</strong> (<em>list</em><em> of </em><em>array-like</em><em>, </em><em>optional</em>) – List of smoothed signal arrays to overlay on the spectrum. Default is None.</p></li>
<li><p><strong>smoothed_labels</strong> (<em>list</em><em> of </em><em>str</em><em>, </em><em>optional</em>) – Labels for each smoothed signal. Default is None.</p></li>
<li><p><strong>label</strong> (<em>str</em><em>, </em><em>optional</em>) – Label for the spectrum. Default is “Spectrum”.</p></li>
<li><p><strong>color</strong> (<em>str</em><em> or </em><em>tuple</em><em>, </em><em>optional</em>) – Base color for the spectrum. If None, a default color will be chosen. Default is None.</p></li>
<li><p><strong>bir</strong> (<em>list</em><em> or </em><em>ndarray</em><em>, </em><em>optional</em>) – Regions of interest to highlight on the plot. Should be a list or array
of shape <cite>(n_regions, 2)</cite>, where each row specifies the start and end of a region
(e.g., <cite>[[x_start1, x_end1], [x_start2, x_end2]]</cite>). Default is None.</p></li>
<li><p><strong>xaxis_title</strong> (<em>str</em><em>, </em><em>optional</em>) – Title for the x-axis. If None, no specific title is set. Default is None.</p></li>
<li><p><strong>yaxis_title</strong> (<em>str</em><em>, </em><em>optional</em>) – Title for the y-axis. If None, no specific title is set. Default is None.</p></li>
<li><p><strong>title</strong> (<em>str</em><em>, </em><em>optional</em>) – Title for the entire plot. If None, no title is set. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The updated Plotly figure object containing the plotted spectrum.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>plotly.graph_objects.Figure</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot a simple spectrum:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">plotly.graph_objects</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">go</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">plot_spectrum</span><span class="p">(</span>
<span class="go">        x=x,</span>
<span class="go">        y=y,</span>
<span class="go">        label=&quot;Sample Spectrum&quot;,</span>
<span class="go">        xaxis_title=&quot;Wavenumber (cm⁻¹)&quot;,</span>
<span class="go">        yaxis_title=&quot;Intensity (a.u.)&quot;,</span>
<span class="go">        title=&quot;Sample Spectrum Analysis&quot;</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Plot a spectrum with baseline and smoothed signal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">baseline</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smoothed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">plot_spectrum</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">baselines</span><span class="o">=</span><span class="p">[</span><span class="n">baseline</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">baseline_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Constant Baseline&quot;</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">smoothed_signals</span><span class="o">=</span><span class="p">[</span><span class="n">smoothed</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">smoothed_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Moving Average&quot;</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">xaxis_title</span><span class="o">=</span><span class="s2">&quot;Wavenumber (cm⁻¹)&quot;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">yaxis_title</span><span class="o">=</span><span class="s2">&quot;Intensity (a.u.)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>All input arrays are automatically converted to vectors using <code class="docutils literal notranslate"><span class="pre">np.asarray(...).flatten()</span></code> to ensure compatibility with Plotly.</p></li>
<li><p>Baselines are displayed as dashed lines with distinct colors.</p></li>
<li><p>Smoothed signals are displayed as dotted lines with distinct colors.</p></li>
<li><p>Regions of interest (BIR) are highlighted with semi-transparent yellow rectangles.</p></li>
<li><p>The function returns the figure object, allowing for further customization if needed.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-rampy.functions">
<span id="rampy-functions-module"></span><h2>rampy.functions module<a class="headerlink" href="#module-rampy.functions" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.constant">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">constant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.functions.constant" title="Link to this definition"></a></dt>
<dd><p>returns a constant value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>1D array</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>y</strong> – array filled with a values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.difffull">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">difffull</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#rampy.functions.difffull" title="Link to this definition"></a></dt>
<dd><p>Equation for the diffusion into a full slab, see Crank 1975</p>
<p>Here we assume the profil to have 2 surfaces of contact on each side</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C0</strong> (<em>float</em>) – the concentration in the core</p></li>
<li><p><strong>C1</strong> (<em>float</em>) – the concentration at the border</p></li>
<li><p><strong>D</strong> (<em>float</em>) – the diffusion coefficient in log10 unit, m^2.s^-1</p></li>
<li><p><strong>x2</strong> (<em>x1 and</em>) – the profil lengths from beginning and end respectively, in meters</p></li>
<li><p><strong>t</strong> (<em>float</em>) – time in seconds</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.diffshort">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">diffshort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.functions.diffshort" title="Link to this definition"></a></dt>
<dd><p>1D equation for the diffusion into a semi-infinite slab, see Crank 1975</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>1D array</em>) – the profil length in meters</p></li>
<li><p><strong>t</strong> (<em>float</em>) – time in seconds</p></li>
<li><p><strong>C0</strong> (<em>float</em>) – the concentration in the core</p></li>
<li><p><strong>C1</strong> (<em>float</em>) – the concentration at the border</p></li>
<li><p><strong>D</strong> (<em>float</em>) – the diffusion coefficient in log10 unit, m^2.s^-1</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Cx</strong> – concentration at x</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.funexp">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">funexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.functions.funexp" title="Link to this definition"></a></dt>
<dd><p>exponential baseline function</p>
<p>a*exp(b*(x-c))</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.funlog">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">funlog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.functions.funlog" title="Link to this definition"></a></dt>
<dd><p>log baseline function</p>
<p>a * ln(-b <a href="#id1"><span class="problematic" id="id2">*</span></a>(x-c)) - d*x**2</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.gauss_lsq">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">gauss_lsq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.functions.gauss_lsq" title="Link to this definition"></a></dt>
<dd><p>predicts a sum of gaussian peaks with parameters params</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>1D array</em>) – an array of the parameters of the peaks. The number of peaks is assumed to be equal to len(params)/3.
In this array, list intensities first, then all peak positions, then all peak half width at half maximum.</p></li>
<li><p><strong>x</strong> (<em>1D array</em>) – x axis</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>y</strong> – y values at position x</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.gauss_lsq_lfix">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">gauss_lsq_lfix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.functions.gauss_lsq_lfix" title="Link to this definition"></a></dt>
<dd><p>predicts a sum of gaussian peaks with parameters params</p>
<p>Assumes that all peaks share the same HWHM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>1D array</em>) – an array of the parameters of the peaks. The number of peaks is assumed to be equal to len(params)/3.
In this array, list intensities first, then all peak positions, then the last element is the peaks’ half width at half maximum.</p></li>
<li><p><strong>x</strong> (<em>1D array</em>) – x axis</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>y</strong> – y values at position x</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.linear">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.functions.linear" title="Link to this definition"></a></dt>
<dd><p>returns a + b*x</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.linear0">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">linear0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.functions.linear0" title="Link to this definition"></a></dt>
<dd><p>returns a*x</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.multigaussian">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">multigaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.functions.multigaussian" title="Link to this definition"></a></dt>
<dd><p>old attempt to have a multigaussian function, do not use. Will be removed soon.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.functions.poly2">
<span class="sig-prename descclassname"><span class="pre">rampy.functions.</span></span><span class="sig-name descname"><span class="pre">poly2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.functions.poly2" title="Link to this definition"></a></dt>
<dd><p>returns a + b*x + c*x*x</p>
</dd></dl>

</section>
<section id="module-rampy.maps">
<span id="rampy-maps-module"></span><h2>rampy.maps module<a class="headerlink" href="#module-rampy.maps" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="rampy.maps.maps">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">rampy.maps.</span></span><span class="sig-name descname"><span class="pre">maps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrometer_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'horiba'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2D'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">despiking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neigh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.maps" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for handling and analyzing Raman spectral maps.</p>
<p>This class provides methods for reading, processing, and analyzing
1D or 2D Raman spectral maps from Horiba or Renishaw spectrometers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<em>str</em>) – Path to the map file.</p></li>
<li><p><strong>spectrometer_type</strong> (<em>str</em><em>, </em><em>optional</em>) – Type of spectrometer.
Must be either ‘horiba’ or ‘renishaw’. Defaults to ‘horiba’.</p></li>
<li><p><strong>map_type</strong> (<em>str</em><em>, </em><em>optional</em>) – Type of map. Must be either ‘2D’ or ‘1D’. Defaults to ‘2D’.</p></li>
<li><p><strong>despiking</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to perform despiking on the spectra. Defaults to False.</p></li>
<li><p><strong>neigh</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of neighboring points for despiking. Defaults to 4.</p></li>
<li><p><strong>threshold</strong> (<em>float</em><em>, </em><em>optional</em>) – Threshold for spike detection. Defaults to 3.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>map_type</cite> is not ‘1D’ or ‘2D’.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="rampy.maps.maps.area">
<span class="sig-name descname"><span class="pre">area</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">region_to_investigate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.maps.area" title="Link to this definition"></a></dt>
<dd><p>Calculates the area under the curve in a specified region.</p>
<p>The area is computed via trapezoidal integration (<cite>np.trapz</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>ndarray</em>) – Intensities to analyze (e.g., <cite>self.I_normalised</cite>).</p></li>
<li><p><strong>region_to_investigate</strong> (<em>array-like</em>) – [min, max] values of the region to integrate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None. Sets <cite>self.A</cite> with the integrated areas for the map.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.maps.maps.area_ratio">
<span class="sig-name descname"><span class="pre">area_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">region_to_investigate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.maps.area_ratio" title="Link to this definition"></a></dt>
<dd><p>Calculates the area ratio between two regions of interest.</p>
<p>The ratio is computed as the integrated area in region 1 divided by the area in region 2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>ndarray</em>) – Intensities to analyze (e.g., <cite>self.I_normalised</cite>).</p></li>
<li><p><strong>region_to_investigate</strong> (<em>ndarray</em>) – 2x2 array, each row [min, max] for the two regions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None. Sets <cite>self.A_ratio</cite> with the area ratios for the map.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.maps.maps.background">
<span class="sig-name descname"><span class="pre">background</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'poly'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.maps.background" title="Link to this definition"></a></dt>
<dd><p>Corrects background from the signal using rampy.baseline.</p>
<p>Applies baseline correction to each spectrum in the map using the specified method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bir</strong> (<em>ndarray</em>) – Regions of interest for baseline fitting.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>Baseline correction method. Defaults to ‘poly’.
Supported methods include:</p>
<blockquote>
<div><ul>
<li><p>’poly’: Polynomial fitting.</p></li>
<li><p>’unispline’: Spline fitting (UnivariateSpline).</p></li>
<li><p>’gcvspline’: GCVSpline fitting.</p></li>
<li><p>’gaussian’: Gaussian function fitting.</p></li>
<li><p>’exp’: Exponential fitting.</p></li>
<li><p>’log’: Logarithmic fitting.</p></li>
<li><p>’rubberband’: Rubberband correction.</p></li>
<li><p>’als’: Asymmetric Least Squares.</p></li>
<li><p>’arPLS’: Asymmetrically Reweighted Penalized Least Squares.</p></li>
<li><p>’drPLS’: Doubly Reweighted Penalized Least Squares.</p></li>
<li><p>’whittaker’: Whittaker smoothing.</p></li>
<li><p>’GP’: Gaussian process method.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>**kwargs</strong> – Additional method-specific parameters, such as:
roi (ndarray): Regions of interest (default: full range).
polynomial_order (int): Polynomial degree for ‘poly’.
s (float): Spline smoothing parameter.
ese_y (ndarray): Errors for ‘gcvspline’.
lam (float): Smoothness parameter for ‘als’, ‘arPLS’, etc.
p (float): Weighting parameter for ‘als’.
ratio (float): Convergence ratio for ‘arPLS’, ‘drPLS’.
niter (int): Number of iterations for ‘als’, ‘drPLS’.
eta (float): Roughness for ‘drPLS’.
p0_gaussian (list): Initial params for ‘gaussian’.
p0_exp (list): Initial params for ‘exp’.
p0_log (list): Initial params for ‘log’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None. Sets <cite>self.I_background</cite> and <cite>self.I_corrected</cite> with the background and background-corrected spectra.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.maps.maps.centroid">
<span class="sig-name descname"><span class="pre">centroid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">region_to_investigate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.maps.centroid" title="Link to this definition"></a></dt>
<dd><p>Calculates the centroid in a given region of interest.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>ndarray</em>) – Intensities to analyze (e.g., <cite>self.I_normalised</cite>).</p></li>
<li><p><strong>region_to_investigate</strong> (<em>array-like</em>) – [min, max] values of the region where the centroid is measured.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None. Sets <cite>self.centroid_position</cite> with the centroid positions for the map.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.maps.maps.intensity">
<span class="sig-name descname"><span class="pre">intensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">region_to_investigate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.maps.intensity" title="Link to this definition"></a></dt>
<dd><p>Finds the maximum intensity in a specified region.</p>
<p>The maximum is estimated using <cite>np.max</cite> within the region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>ndarray</em>) – Intensities to analyze (e.g., <cite>self.I_normalised</cite>).</p></li>
<li><p><strong>region_to_investigate</strong> (<em>array-like</em>) – [min, max] values of the region to search for the maximum.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None. Sets <cite>self.I_max</cite> with the intensity maxima for the map.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.maps.maps.intensity_ratio">
<span class="sig-name descname"><span class="pre">intensity_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">region_to_investigate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.maps.intensity_ratio" title="Link to this definition"></a></dt>
<dd><p>Calculates the intensity ratio between two regions of interest.</p>
<p>The ratio is computed as the maximum intensity in region 1 divided by the maximum in region 2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>ndarray</em>) – Intensities to analyze (e.g., <cite>self.I_normalised</cite>).</p></li>
<li><p><strong>region_to_investigate</strong> (<em>ndarray</em>) – 2x2 array, each row [min, max] for the two regions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None. Sets <cite>self.I_ratio</cite> with the intensity ratios for the map.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.maps.maps.normalise">
<span class="sig-name descname"><span class="pre">normalise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'intensity'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.maps.normalise" title="Link to this definition"></a></dt>
<dd><p>Normalises the spectra using rampy.normalise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>ndarray</em>) – Intensities to normalise (e.g., <cite>self.I_corrected</cite>).</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Normalisation method. One of ‘area’, ‘intensity’, or ‘minmax’. Defaults to ‘intensity’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None. Sets <cite>self.I_normalised</cite> with the normalised spectra.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.maps.maps.smooth">
<span class="sig-name descname"><span class="pre">smooth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'whittaker'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.maps.smooth" title="Link to this definition"></a></dt>
<dd><p>Smooths spectra using rampy.smooth.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>ndarray</em>) – Intensities to smooth (e.g., <cite>self.I_corrected</cite>).</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Smoothing method. Supported methods include:
‘savgol’, ‘GCVSmoothedNSpline’, ‘MSESmoothedNSpline’, ‘DOFSmoothedNSpline’,
‘whittaker’, ‘flat’, ‘hanning’, ‘hamming’, ‘bartlett’, ‘blackman’.
Defaults to ‘whittaker’.</p></li>
<li><p><strong>**kwargs</strong> – Additional method-specific parameters, such as:
window_length (int): Length of the filter window (for Savitzky-Golay).
polyorder (int): Polynomial order (for Savitzky-Golay).
Lambda (float): Smoothing parameter for Whittaker filter.
d (int): Parameter for Whittaker filter.
ese_y (ndarray): Errors for spline algorithms.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None. Sets <cite>self.y_smoothed</cite> with the smoothed spectra.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.maps.peak">
<span class="sig-prename descclassname"><span class="pre">rampy.maps.</span></span><span class="sig-name descname"><span class="pre">peak</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambdas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xrange</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xmean</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.peak" title="Link to this definition"></a></dt>
<dd><p>to fit peaks in a map. Work in progress.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.maps.read_horiba">
<span class="sig-prename descclassname"><span class="pre">rampy.maps.</span></span><span class="sig-name descname"><span class="pre">read_horiba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2D'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.read_horiba" title="Link to this definition"></a></dt>
<dd><p>read Horiba csv maps (1D, 2D)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<em>str</em>) – filename, including path</p></li>
<li><p><strong>map_type</strong> (<em>str</em>) – 1D map (line) or 2D map, default: 2D</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>X</strong> (<em>m by n array</em>) – X positions</p></li>
<li><p><strong>Y</strong> (<em>m by n array</em>) – Y position</p></li>
<li><p><strong>lambdas</strong> (<em>n array</em>) – Raman shift</p></li>
<li><p><strong>intensities</strong> (<em>m by n array</em>) – Intensities</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.maps.read_renishaw">
<span class="sig-prename descclassname"><span class="pre">rampy.maps.</span></span><span class="sig-name descname"><span class="pre">read_renishaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.maps.read_renishaw" title="Link to this definition"></a></dt>
<dd><p>read Renishaw csv maps</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file</strong> (<em>str</em>) – filename, including path</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>X</strong> (<em>m by n array</em>) – X positions</p></li>
<li><p><strong>Y</strong> (<em>m by n array</em>) – Y position</p></li>
<li><p><strong>lambdas</strong> (<em>m by n array</em>) – Raman shift</p></li>
<li><p><strong>intensities</strong> (<em>m by n array</em>) – Intensities</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-rampy.mixing">
<span id="rampy-mixing-module"></span><h2>rampy.mixing module<a class="headerlink" href="#module-rampy.mixing" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.mixing.mixing_sp">
<span class="sig-prename descclassname"><span class="pre">rampy.mixing.</span></span><span class="sig-name descname"><span class="pre">mixing_sp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_fit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.mixing.mixing_sp" title="Link to this definition"></a></dt>
<dd><blockquote>
<div><p>Mixes two reference spectra to match given experimental signals.</p>
<p>This function calculates the fractions of the first reference spectrum (<cite>ref1</cite>)
in a linear combination of <cite>ref1</cite> and <cite>ref2</cite> that best matches the provided signals (<cite>y_fit</cite>).
The calculation minimizes the sum of the least absolute values of the objective function:
(  ext{obj} = sum left| y_{      ext{fit}} - (F_1 cdot  ext{ref1} + (1 - F_1) cdot     ext{ref2})</p>
</div></blockquote>
<p>ight| ).</p>
<blockquote>
<div><dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>y_fit (np.ndarray): Array containing the experimental signals with shape <cite>(m, n)</cite>,</dt><dd><p>where <cite>m</cite> is the number of data points and <cite>n</cite> is the number of experiments.</p>
</dd>
</dl>
<p>ref1 (np.ndarray): Array containing the first reference signal with shape <cite>(m,)</cite>.
ref2 (np.ndarray): Array containing the second reference signal with shape <cite>(m,)</cite>.</p>
</dd>
<dt>Returns:</dt><dd><p>np.ndarray: Array of shape <cite>(n,)</cite> containing the fractions of <cite>ref1</cite> in the mix.
Values range between 0 and 1.</p>
</dd>
<dt>Notes:</dt><dd><ul class="simple">
<li><p>The calculation is performed using <cite>cvxpy</cite> for optimization.</p></li>
<li><p>Ensure that <cite>y_fit</cite>, <cite>ref1</cite>, and <cite>ref2</cite> have compatible dimensions.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fractions</span> <span class="o">=</span> <span class="n">mixing_sp</span><span class="p">(</span><span class="n">y_fit</span><span class="p">,</span> <span class="n">ref1</span><span class="p">,</span> <span class="n">ref2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fractions</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

</section>
<section id="module-rampy.ml_classification">
<span id="rampy-ml-classification-module"></span><h2>rampy.ml_classification module<a class="headerlink" href="#module-rampy.ml_classification" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">rampy.ml_classification.</span></span><span class="sig-name descname"><span class="pre">mlclassificator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_classification.mlclassificator" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Perform automatic classification of spectral data using scikit-learn machine learning algorithms.</p>
<p>This class supports various classification algorithms and allows customization of hyperparameters.
It also handles scaling and splitting of training and testing datasets.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.x">
<span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.x" title="Link to this definition"></a></dt>
<dd><p>Training spectra organized in rows (1 row = one spectrum).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.y">
<span class="sig-name descname"><span class="pre">y</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.y" title="Link to this definition"></a></dt>
<dd><p>Target labels for training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.X_test">
<span class="sig-name descname"><span class="pre">X_test</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.X_test" title="Link to this definition"></a></dt>
<dd><p>Testing spectra organized in rows.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.y_test">
<span class="sig-name descname"><span class="pre">y_test</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.y_test" title="Link to this definition"></a></dt>
<dd><p>Target labels for testing data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.algorithm">
<span class="sig-name descname"><span class="pre">algorithm</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.algorithm" title="Link to this definition"></a></dt>
<dd><p>Machine learning algorithm to use. Options:
“Nearest Neighbors”, “Linear SVM”, “RBF SVM”, “Gaussian Process”,
“Decision Tree”, “Random Forest”, “Neural Net”, “AdaBoost”,
“Naive Bayes”, “QDA”.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.scaling">
<span class="sig-name descname"><span class="pre">scaling</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.scaling" title="Link to this definition"></a></dt>
<dd><p>Whether to scale the data during fitting and prediction.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.scaler">
<span class="sig-name descname"><span class="pre">scaler</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.scaler" title="Link to this definition"></a></dt>
<dd><p>Type of scaler to use (“MinMaxScaler” or “StandardScaler”).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.test_size">
<span class="sig-name descname"><span class="pre">test_size</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.test_size" title="Link to this definition"></a></dt>
<dd><p>Fraction of the dataset to use as a testing dataset if X_test and y_test are not provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.rand_state">
<span class="sig-name descname"><span class="pre">rand_state</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.rand_state" title="Link to this definition"></a></dt>
<dd><p>Random seed for reproducibility. Default is 42.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.params_">
<span class="sig-name descname"><span class="pre">params_</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.params_" title="Link to this definition"></a></dt>
<dd><p>Hyperparameters for the selected algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.model">
<span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.model" title="Link to this definition"></a></dt>
<dd><p>Scikit-learn model instance.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.X_scaler">
<span class="sig-name descname"><span class="pre">X_scaler</span></span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.X_scaler" title="Link to this definition"></a></dt>
<dd><p>Scikit-learn scaler instance for X values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params_</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.fit" title="Link to this definition"></a></dt>
<dd><p>Scale data and train or re-train the model with the specified algorithm.</p>
<p>This method initializes and trains the model if it hasn’t been trained yet. If a model
already exists (from a previous fit), it reuses the existing model and optionally updates
its hyperparameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>params</strong> (<em>dict</em><em>, </em><em>optional</em>) – Hyperparameters for the selected algorithm. If provided,
these parameters will override any previously set parameters.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If an invalid algorithm is specified or if scaling is inconsistent.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.predict" title="Link to this definition"></a></dt>
<dd><p>Predict target values using the trained model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>np.ndarray</em>) – Samples to predict with shape <cite>(n_samples, n_features)</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Predicted target values with shape <cite>(n_samples,)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>scaling</cite> is enabled, input samples will be scaled before prediction.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the model has not been fitted yet.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.refit">
<span class="sig-name descname"><span class="pre">refit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.refit" title="Link to this definition"></a></dt>
<dd><p>Re-train a model previously trained with fit()</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.ml_classification.mlclassificator.scale_data">
<span class="sig-name descname"><span class="pre">scale_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_classification.mlclassificator.scale_data" title="Link to this definition"></a></dt>
<dd><p>Scale training and testing data.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-rampy.ml_exploration">
<span id="rampy-ml-exploration-module"></span><h2>rampy.ml_exploration module<a class="headerlink" href="#module-rampy.ml_exploration" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">rampy.ml_exploration.</span></span><span class="sig-name descname"><span class="pre">mlexplorer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>use machine learning algorithms from scikit learn to explore spectroscopic datasets</p>
<p>Performs automatic scaling and train/test split before NMF or PCA fit.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.x">
<span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.x" title="Link to this definition"></a></dt>
<dd><p>Spectra; n_features = n_frequencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>{array-like, sparse matrix}, shape = (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.X_test">
<span class="sig-name descname"><span class="pre">X_test</span></span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.X_test" title="Link to this definition"></a></dt>
<dd><p>spectra organised in rows (1 row = one spectrum) that you want to use as a testing dataset. THose spectra should not be present in the x (training) dataset. The spectra should share a common X axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>{array-like, sparse matrix}, shape = (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.algorithm">
<span class="sig-name descname"><span class="pre">algorithm</span></span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.algorithm" title="Link to this definition"></a></dt>
<dd><p>“PCA”, “NMF”, default = “PCA”</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>String,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.scaling">
<span class="sig-name descname"><span class="pre">scaling</span></span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.scaling" title="Link to this definition"></a></dt>
<dd><p>True or False. If True, data will be scaled prior to fitting (see below),</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.scaler">
<span class="sig-name descname"><span class="pre">scaler</span></span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.scaler" title="Link to this definition"></a></dt>
<dd><p>the type of scaling performed. Choose between MinMaxScaler or StandardScaler, see <a class="reference external" href="http://scikit-learn.org/stable/modules/preprocessing.html">http://scikit-learn.org/stable/modules/preprocessing.html</a> for details. Default = “MinMaxScaler”.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>String</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.test_size">
<span class="sig-name descname"><span class="pre">test_size</span></span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.test_size" title="Link to this definition"></a></dt>
<dd><p>the fraction of the dataset to use as a testing dataset; only used if X_test and y_test are not provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.rand_state">
<span class="sig-name descname"><span class="pre">rand_state</span></span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.rand_state" title="Link to this definition"></a></dt>
<dd><p>the random seed that is used for reproductibility of the results. Default = 42.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float64</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.model">
<span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.model" title="Link to this definition"></a></dt>
<dd><p>A Scikit Learn object model, see scikit learn library documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Scikit learn model</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.Remarks">
<span class="sig-name descname"><span class="pre">Remarks</span></span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.Remarks" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">-------</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">For</span> <span class="pre">details</span> <span class="pre">on</span> <span class="pre">hyperparameters</span> <span class="pre">of</span> <span class="pre">each</span> <span class="pre">algorithms,</span> <span class="pre">please</span> <span class="pre">directly</span> <span class="pre">consult</span> <span class="pre">the</span> <span class="pre">documentation</span> <span class="pre">of</span> <span class="pre">SciKit</span> <span class="pre">Learn</span> <span class="pre">at</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.http">
<span class="sig-name descname"><span class="pre">http</span></span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.http" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>//scikit-learn.org/stable/</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Results</span> <span class="pre">for</span> <span class="pre">machine</span> <span class="pre">learning</span> <span class="pre">algorithms</span> <span class="pre">can</span> <span class="pre">vary</span> <span class="pre">from</span> <span class="pre">run</span> <span class="pre">to</span> <span class="pre">run.</span> <span class="pre">A</span> <span class="pre">way</span> <span class="pre">to</span> <span class="pre">solve</span> <span class="pre">that</span> <span class="pre">is</span> <span class="pre">to</span> <span class="pre">fix</span> <span class="pre">the</span> <span class="pre">random_state.</span></span></dt>
<dd></dd></dl>

<p class="rubric">Example</p>
<p>Given an array X of n samples by m frequencies, and Y an array of n x 1 concentrations</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">explo</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">mlexplorer</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># X is an array of signals built by mixing two partial components</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">explo</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;NMF&#39;</span> <span class="c1"># using Non-Negative Matrix factorization</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">explo</span><span class="o">.</span><span class="n">nb_compo</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># number of components to use</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">explo</span><span class="o">.</span><span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="c1"># size of test set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">explo</span><span class="o">.</span><span class="n">scaler</span> <span class="o">=</span> <span class="s2">&quot;MinMax&quot;</span> <span class="c1"># scaler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">explo</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span> <span class="c1"># fitting!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span> <span class="o">=</span> <span class="n">explo</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">explo</span><span class="o">.</span><span class="n">X_train_sc</span><span class="p">)</span> <span class="c1"># getting the mixture array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">explo</span><span class="o">.</span><span class="n">X_scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">explo</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">components_</span><span class="p">)</span> <span class="c1"># components in the original space</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># plot the two components</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.fit" title="Link to this definition"></a></dt>
<dd><p>Train the model with the indicated algorithm.</p>
<p>Do not forget to tune the hyperparameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.predict" title="Link to this definition"></a></dt>
<dd><p>Predict using the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape =</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>C</strong> (<em>array, shape = (n_samples,)</em>) – Returns predicted values.</p></li>
<li><p><em>Remark</em></p></li>
<li><p><em>——</em></p></li>
<li><p><em>if self.scaling == “yes”, scaling will be performed on the input X.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.ml_exploration.mlexplorer.refit">
<span class="sig-name descname"><span class="pre">refit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_exploration.mlexplorer.refit" title="Link to this definition"></a></dt>
<dd><p>Train the model with the indicated algorithm.</p>
<p>Do not forget to tune the hyperparameters.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-rampy.ml_regressor">
<span id="rampy-ml-regressor-module"></span><h2>rampy.ml_regressor module<a class="headerlink" href="#module-rampy.ml_regressor" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.ml_regressor.chemical_splitting">
<span class="sig-prename descclassname"><span class="pre">rampy.ml_regressor.</span></span><span class="sig-name descname"><span class="pre">chemical_splitting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Pandas_DataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rand_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_regressor.chemical_splitting" title="Link to this definition"></a></dt>
<dd><p>split datasets depending on a target (e.g. sample composition)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Pandas_DataFrame</strong> (<em>Pandas DataFrame</em>) – The input DataFrame with in the first row the names of the different data compositions</p></li>
<li><p><strong>label</strong> (<em>string</em>) – The target in the DataFrame according to which we will split the dataset</p></li>
<li><p><strong>split_fraction</strong> (<em>float</em><em>, </em><em>between 0 and 1</em>) – This is the amount of splitting you want, in reference to the second output dataset (see OUTPUTS).</p></li>
<li><p><strong>rand_state</strong> (<em>float64</em>) – the random seed that is used for reproductibility of the results. Default = 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>frame1</strong> (<em>Pandas DataFrame</em>) – A DataSet with (1-split_fraction) datas from the input dataset with unique chemical composition / names</p></li>
<li><p><strong>frame2</strong> (<em>Pandas DataFrame</em>) – A DataSet with split_fraction datas from the input dataset with unique chemical composition / names</p></li>
<li><p><strong>frame1_idx</strong> (<em>ndarray</em>) – Contains the indexes of the data picked in Pandas_DataFrame to construct frame1</p></li>
<li><p><strong>frame2_idx</strong> (<em>ndarray</em>) – Contains the indexes of the data picked in Pandas_DataFrame to construct frame2</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function avoids the same chemical dataset to be found in different training/testing/validating datasets that are used in ML.</p>
<p>Indeed, it is worthless to put data from the same original dataset / with the same chemical composition
in the training / testing / validating datasets. This creates a initial bias in the splitting process…</p>
<p>Another way of doing that would be to write:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">Pandas_DataFrame</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grouped</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k_train</span><span class="p">,</span> <span class="n">k_valid</span> <span class="o">=</span> <span class="n">model_selection</span><span class="o">.</span><span class="n">train_test_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">test_size</span><span class="o">=</span><span class="mf">0.40</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span> <span class="o">=</span> <span class="n">Pandas_DataFrame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">Pandas_DataFrame</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">k_train</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">valid</span> <span class="o">=</span> <span class="n">Pandas_DataFrame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">Pandas_DataFrame</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">k_valid</span><span class="p">)]</span>
</pre></div>
</div>
<p>(results will vary slightly as variable k is sorted but not variable names in the function below)</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">rampy.ml_regressor.</span></span><span class="sig-name descname"><span class="pre">mlregressor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_regressor.mlregressor" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>use machine learning algorithms from scikit learn to perform regression between spectra and an observed variable.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.x">
<span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.x" title="Link to this definition"></a></dt>
<dd><p>Spectra; n_features = n_frequencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>{array-like, sparse matrix}, shape = (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.y">
<span class="sig-name descname"><span class="pre">y</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.y" title="Link to this definition"></a></dt>
<dd><p>Returns predicted values.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, shape = (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.X_test">
<span class="sig-name descname"><span class="pre">X_test</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.X_test" title="Link to this definition"></a></dt>
<dd><p>spectra organised in rows (1 row = one spectrum) that you want to use as a testing dataset. THose spectra should not be present in the x (training) dataset. The spectra should share a common X axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>{array-like, sparse matrix}, shape = (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.y_test">
<span class="sig-name descname"><span class="pre">y_test</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.y_test" title="Link to this definition"></a></dt>
<dd><p>the target that you want to use as a testing dataset. Those targets should not be present in the y (training) dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, shape = (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.algorithm">
<span class="sig-name descname"><span class="pre">algorithm</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.algorithm" title="Link to this definition"></a></dt>
<dd><p>“KernelRidge”, “SVM”, “LinearRegression”, “Lasso”, “ElasticNet”, “NeuralNet”, “BaggingNeuralNet”, default = “SVM”</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>String,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.scaling">
<span class="sig-name descname"><span class="pre">scaling</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.scaling" title="Link to this definition"></a></dt>
<dd><p>True or False. If True, data will be scaled during fitting and prediction with the requested scaler (see below),</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.scaler">
<span class="sig-name descname"><span class="pre">scaler</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.scaler" title="Link to this definition"></a></dt>
<dd><p>the type of scaling performed. Choose between MinMaxScaler or StandardScaler, see <a class="reference external" href="http://scikit-learn.org/stable/modules/preprocessing.html">http://scikit-learn.org/stable/modules/preprocessing.html</a> for details. Default = “MinMaxScaler”.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>String</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.test_size">
<span class="sig-name descname"><span class="pre">test_size</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.test_size" title="Link to this definition"></a></dt>
<dd><p>the fraction of the dataset to use as a testing dataset; only used if X_test and y_test are not provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.rand_state">
<span class="sig-name descname"><span class="pre">rand_state</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.rand_state" title="Link to this definition"></a></dt>
<dd><p>the random seed that is used for reproductibility of the results. Default = 42.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float64</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.param_kr">
<span class="sig-name descname"><span class="pre">param_kr</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.param_kr" title="Link to this definition"></a></dt>
<dd><p>contain the values of the hyperparameters that should be provided to KernelRidge and GridSearch for the Kernel Ridge regression algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.param_svm">
<span class="sig-name descname"><span class="pre">param_svm</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.param_svm" title="Link to this definition"></a></dt>
<dd><p>containg the values of the hyperparameters that should be provided to SVM and GridSearch for the Support Vector regression algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.param_neurons">
<span class="sig-name descname"><span class="pre">param_neurons</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.param_neurons" title="Link to this definition"></a></dt>
<dd><p>contains the parameters for the Neural Network (MLPregressor model in sklearn).
Default= dict(hidden_layer_sizes=(3,),solver = ‘lbfgs’,activation=’relu’,early_stopping=True)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.param_bagging">
<span class="sig-name descname"><span class="pre">param_bagging</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.param_bagging" title="Link to this definition"></a></dt>
<dd><p>contains the parameters for the BaggingRegressor sklearn function that uses a MLPregressor base method.
Default= dict(n_estimators=100, max_samples=1.0, max_features=1.0, bootstrap=True,</p>
<blockquote>
<div><p>bootstrap_features=False, oob_score=False, warm_start=False, n_jobs=1, random_state=rand_state, verbose=0)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.prediction_train">
<span class="sig-name descname"><span class="pre">prediction_train</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.prediction_train" title="Link to this definition"></a></dt>
<dd><p>the predicted target values for the training y dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Array{Float64}</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.prediction_test">
<span class="sig-name descname"><span class="pre">prediction_test</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.prediction_test" title="Link to this definition"></a></dt>
<dd><p>the predicted target values for the testing y_test dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Array{Float64}</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.model">
<span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.model" title="Link to this definition"></a></dt>
<dd><p>A Scikit Learn object model, see scikit learn library documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Scikit learn model</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.X_scaler">
<span class="sig-name descname"><span class="pre">X_scaler</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.X_scaler" title="Link to this definition"></a></dt>
<dd><p>A Scikit Learn scaler object for the x values.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.Y_scaler">
<span class="sig-name descname"><span class="pre">Y_scaler</span></span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.Y_scaler" title="Link to this definition"></a></dt>
<dd><p>A Scikit Learn scaler object for the y values.</p>
</dd></dl>

<p class="rubric">Example</p>
<p>Given an array X of n samples by m frequencies, and Y an array of n x 1 concentrations</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">mlregressor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">algorithm</span><span class="p">(</span><span class="s2">&quot;SVM&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">user_kernel</span> <span class="o">=</span> <span class="s1">&#39;poly&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_new</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>
</pre></div>
</div>
<section id="remarks">
<h3>Remarks<a class="headerlink" href="#remarks" title="Link to this heading"></a></h3>
<p>For details on hyperparameters of each algorithms, please directly consult the documentation of SciKit Learn at:</p>
<p><a class="reference external" href="http://scikit-learn.org/stable/">http://scikit-learn.org/stable/</a></p>
<p>For Support Vector and Kernel Ridge regressions, mlregressor performs a cross_validation search with using 5 KFold cross validators.</p>
<p>If the results are poor with Support Vector and Kernel Ridge regressions, you will have to tune the param_grid_kr or param_grid_svm dictionnary that records the hyperparameter space to investigate during the cross validation.</p>
<p>Results for machine learning algorithms can vary from run to run. A way to solve that is to fix the random_state.
For neural nets, results from multiple neural nets (bagging technique) may also generalise better, such that
it may be better to use the BaggingNeuralNet function.</p>
<dl class="py method">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.fit" title="Link to this definition"></a></dt>
<dd><p>Scale data and train the model with the indicated algorithm.</p>
<p>Do not forget to tune the hyperparameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>algorithm</strong> (<em>String</em><em>,</em>) – algorithm to use. Choose between “KernelRidge”, “SVM”, “LinearRegression”, “Lasso”, “ElasticNet”, “NeuralNet”, “BaggingNeuralNet”, default = “SVM”</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.predict" title="Link to this definition"></a></dt>
<dd><p>Predict using the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape =</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>C</strong> (<em>array, shape = (n_samples,)</em>) – Returns predicted values.</p></li>
<li><p><em>Remark</em></p></li>
<li><p><em>——</em></p></li>
<li><p><em>if self.scaling == “yes”, scaling will be performed on the input X.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.ml_regressor.mlregressor.refit">
<span class="sig-name descname"><span class="pre">refit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rampy.ml_regressor.mlregressor.refit" title="Link to this definition"></a></dt>
<dd><p>Re-train a model previously trained with fit()</p>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="module-rampy.peak_area">
<span id="rampy-peak-area-module"></span><h2>rampy.peak_area module<a class="headerlink" href="#module-rampy.peak_area" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.peak_area.area_peak">
<span class="sig-prename descclassname"><span class="pre">rampy.peak_area.</span></span><span class="sig-name descname"><span class="pre">area_peak</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">peak_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Literal</span><span class="p"><span class="pre">[</span></span><span class="s"><span class="pre">'gaussian'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'lorentzian'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'pseudovoigt'</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="s"><span class="pre">'pearson7'</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hwhm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lorentzian_fraction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exponent</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#rampy.peak_area.area_peak" title="Link to this definition"></a></dt>
<dd><p>Calculates the analytical area under a peak based on its type and parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peak_type</strong> – Type of peak (gaussian, lorentzian, pseudovoigt, pearson7)</p></li>
<li><p><strong>amplitude</strong> – Amplitude of the peak (maximum height)</p></li>
<li><p><strong>hwhm</strong> – Half-width at half-maximum of the peak</p></li>
<li><p><strong>lorentzian_fraction</strong> – Lorentzian fraction for Pseudo-Voigt [0, 1]</p></li>
<li><p><strong>exponent</strong> – Shape parameter for Pearson VII</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Area under the specified peak</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – For invalid arguments or missing required parameters</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">area_peaks</span><span class="p">(</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.3548200450309493</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">area_peaks</span><span class="p">(</span><span class="s2">&quot;pseudovoigt&quot;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">lorentzian_fraction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">3.141592653589793</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.peak_area.gaussianarea">
<span class="sig-prename descclassname"><span class="pre">rampy.peak_area.</span></span><span class="sig-name descname"><span class="pre">gaussianarea</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HWHM</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.peak_area.gaussianarea" title="Link to this definition"></a></dt>
<dd><p>returns the area of a Gaussian peak</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>amp</strong> (<em>float</em><em> or </em><em>ndarray</em>) – amplitude of the peak</p></li>
<li><p><strong>HWHM</strong> (<em>float</em><em> or </em><em>ndarray</em>) – half-width at half-maximum</p></li>
<li><p><strong>eseAmplitude</strong> (<em>float</em><em> or </em><em>ndarray</em><em>, </em><em>optional</em>) – standard deviation on amp; Default = None</p></li>
<li><p><strong>eseHWHM</strong> (<em>float</em><em> or </em><em>ndarray</em><em>, </em><em>optional</em>) – standard deviation on HWHM; Default = None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>peak area
esearea  (float or ndarray): error on peak area; will be None if no errors on amp and HWHM were provided.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>area (float or ndarray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.peak_area.peakarea">
<span class="sig-prename descclassname"><span class="pre">rampy.peak_area.</span></span><span class="sig-name descname"><span class="pre">peakarea</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HWHM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a3</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ese_amp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ese_HWHM</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#rampy.peak_area.peakarea" title="Link to this definition"></a></dt>
<dd><p>Computes the area of a peak given its shape and parameters.</p>
<p><strong>warning: this function will be deprecated in a futur release, use the function area_peak instead!</strong></p>
<p>For Gaussian peaks, the area is calculated analytically. For other shapes
(Lorentzian, pseudo-Voigt, Pearson VII), the area is calculated using numerical
integration (trapezoidal rule).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>str</em>) – The shape of the peak. Must be one of ‘gaussian’, ‘lorentzian’,
‘pseudovoigt’, or ‘pearson7’.</p></li>
<li><p><strong>amp</strong> (<em>float</em><em>, </em><em>list</em><em> of </em><em>floats</em><em>, or </em><em>np.ndarray</em>) – Amplitude of the peak.</p></li>
<li><p><strong>HWHM</strong> (<em>float</em><em>, </em><em>list</em><em> of </em><em>floats</em><em>, or </em><em>np.ndarray</em>) – Half-width at half-maximum of the peak.</p></li>
<li><p><strong>pos</strong> (<em>float</em><em>, </em><em>list</em><em> of </em><em>floats</em><em>, </em><em>np.ndarray</em><em>, </em><em>optional</em>) – Peak position (required for non-Gaussian shapes). Default is None.</p></li>
<li><p><strong>a3</strong> (<em>float</em><em>, </em><em>list</em><em> of </em><em>floats</em><em>, </em><em>np.ndarray</em><em>, </em><em>optional</em>) – Shape parameter for Pearson VII peaks. Required if <cite>shape=’pearson7’</cite>.</p></li>
<li><p><strong>L_ratio</strong> (<em>float</em><em>, </em><em>list</em><em> of </em><em>floats</em><em>, </em><em>np.ndarray</em><em>, </em><em>optional</em>) – Lorentzian component ratio for pseudo-Voigt peaks. Must be between 0 and 1.
Required if <cite>shape=’pseudovoigt’</cite>. Default is None.</p></li>
<li><p><strong>ese_amp</strong> (<em>float</em><em>, </em><em>list</em><em> of </em><em>floats</em><em>, </em><em>np.ndarray</em><em>, </em><em>optional</em>) – Standard deviation of the amplitude. Used to calculate error on area.
Default is None.</p></li>
<li><p><strong>ese_HWHM</strong> (<em>float</em><em>, </em><em>list</em><em> of </em><em>floats</em><em>, </em><em>np.ndarray</em><em>, </em><em>optional</em>) – Standard deviation of HWHM. Used to calculate error on area.
Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple containing:</dt><dd><ul class="simple">
<li><p>area (float): The computed area of the peak.</p></li>
<li><p>ese_area (float or None): The error on the computed area if <cite>ese_amp</cite> and
<cite>ese_HWHM</cite> are provided; otherwise, None.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[float, float | None]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If required parameters are missing or invalid, or if the list of floats or the np.ndarray for the peak parameters have different sizes.</p></li>
<li><p><strong>NotImplementedError</strong> – If an unsupported shape is specified.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>For Gaussian peaks, the formula used is:
(    ext{area} = sqrt{pi / ln(2)} cdot   ext{amp} cdot  ext{HWHM} ).</p></li>
<li><p>For other shapes, numerical integration is performed over a range of ( pm 10 cdot  ext{HWHM} ).</p></li>
</ul>
<p class="rubric">Example</p>
<p>Compute the area of a Gaussian peak:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">HWHM</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">area</span><span class="p">,</span> <span class="n">ese_area</span> <span class="o">=</span> <span class="n">peakarea</span><span class="p">(</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="n">amp</span><span class="p">,</span> <span class="n">HWHM</span><span class="o">=</span><span class="n">HWHM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the area of a Lorentzian peak with numerical integration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">HWHM</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">area</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">peakarea</span><span class="p">(</span><span class="s2">&quot;lorentzian&quot;</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="n">amp</span><span class="p">,</span> <span class="n">HWHM</span><span class="o">=</span><span class="n">HWHM</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the area of several Lorentzian peaks with numerical integration (beware that in this case, the lists should have equal sizes):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">amp</span> <span class="o">=</span> <span class="p">[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">HWHM</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># they share a common width</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">area</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">peakarea</span><span class="p">(</span><span class="s2">&quot;lorentzian&quot;</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="n">amp</span><span class="p">,</span> <span class="n">HWHM</span><span class="o">=</span><span class="n">HWHM</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-rampy.peak_shapes">
<span id="rampy-peak-shapes-module"></span><h2>rampy.peak_shapes module<a class="headerlink" href="#module-rampy.peak_shapes" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.peak_shapes.gaussian">
<span class="sig-prename descclassname"><span class="pre">rampy.peak_shapes.</span></span><span class="sig-name descname"><span class="pre">gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HWHM</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.peak_shapes.gaussian" title="Link to this definition"></a></dt>
<dd><p>Computes a Gaussian peak.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – x axis</p></li>
<li><p><strong>amp</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak amplitude</p></li>
<li><p><strong>freq</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak position</p></li>
<li><p><strong>HWHM</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak half-width at half-maximum.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>calculated peak.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Formula used: (        ext{amp} cdot exp(-log(2) cdot ((x -        ext{freq}) /    ext{HWHM})^2) ).</p>
<p class="rubric">Examples</p>
<p>You can create a single peak like:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also create an array with several peaks in columns using arrays for the peak parameters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mf">10.</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]))</span>
</pre></div>
</div>
<p>In this case, <cite>y</cite> will be an array of shape (len(x), 2) with one peak per columns. Your peaks can even share parameters, here the HWHM:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mf">10.</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]]),</span> <span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>The composite signal is simply given by</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.peak_shapes.lorentzian">
<span class="sig-prename descclassname"><span class="pre">rampy.peak_shapes.</span></span><span class="sig-name descname"><span class="pre">lorentzian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HWHM</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.peak_shapes.lorentzian" title="Link to this definition"></a></dt>
<dd><p>Computes a Lorentzian peak.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – x axis</p></li>
<li><p><strong>amp</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak amplitude</p></li>
<li><p><strong>freq</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak position</p></li>
<li><p><strong>HWHM</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak half-width at half-maximum.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>calculated peak.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Formula used: (        ext{amp} / (1 + ((x -   ext{freq}) /    ext{HWHM})^2) ).</p>
<p class="rubric">Examples</p>
<p>You can create a single peak like:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">lorentzian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also create an array with several peaks in columns using arrays for the peak parameters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">lorentzian</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mf">10.</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]))</span>
</pre></div>
</div>
<p>In this case, <cite>y</cite> will be an array of shape (len(x), 2) with one peak per columns. Your peaks can even share parameters, here the HWHM:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">lorentzian</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mf">10.</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]]),</span> <span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>The composite signal is simply given by</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.peak_shapes.pearson7">
<span class="sig-prename descclassname"><span class="pre">rampy.peak_shapes.</span></span><span class="sig-name descname"><span class="pre">pearson7</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.peak_shapes.pearson7" title="Link to this definition"></a></dt>
<dd><p>Computes a Pearson VII peak.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – Positions at which the signal should be sampled.</p></li>
<li><p><strong>x</strong> – x axis</p></li>
<li><p><strong>a0</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak amplitude</p></li>
<li><p><strong>a1</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak position</p></li>
<li><p><strong>a2</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak width</p></li>
<li><p><strong>a3</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak shape parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The computed Pearson VII signal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Formula used: ( a_0 / ((1 + ((x - a_1) / a_2)^2 cdot (2^{(1/a_3)} - 1))^{a_3}) ).</p>
<p class="rubric">Examples</p>
<p>You can create a single peak like:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">pearson7</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also create an array with several peaks in columns using arrays for the peak parameters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">pearson7</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]))</span>
</pre></div>
</div>
<p>In this case, <cite>y</cite> will be an array of shape (len(x), 2) with one peak per columns. Your peaks can even share parameters, here the a3:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">pearson7</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]),</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>The composite signal is simply given by</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.peak_shapes.pseudovoigt">
<span class="sig-prename descclassname"><span class="pre">rampy.peak_shapes.</span></span><span class="sig-name descname"><span class="pre">pseudovoigt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">HWHM</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_ratio</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.peak_shapes.pseudovoigt" title="Link to this definition"></a></dt>
<dd><p>Computes a pseudo-Voigt peak.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – x axis</p></li>
<li><p><strong>amp</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak amplitude</p></li>
<li><p><strong>freq</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak position</p></li>
<li><p><strong>HWHM</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Peak half-width at half-maximum.</p></li>
<li><p><strong>L_ratio</strong> (<em>float</em>) – Ratio of the Lorentzian component, must be between 0 and 1 (inclusive).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The computed pseudo-Voigt signal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>L_ratio</cite> is not between 0 and 1.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Formula used: ( (1 - L_{       ext{ratio}}) cdot      ext{gaussian}(x,        ext{amp},       ext{freq},      ext{HWHM}) +</dt><dd><p>L_{       ext{ratio}} cdot       ext{lorentzian}(x,      ext{amp},       ext{freq},      ext{HWHM}) ).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>You can create a single peak like:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">pseudovoigt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also create an array with several peaks in columns using arrays for the peak parameters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">pseudovoigt</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]))</span>
</pre></div>
</div>
<p>In this case, <cite>y</cite> will be an array of shape (len(x), 2) with one peak per columns. Your peaks can even share parameters, here the L_ratio:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rampy</span><span class="o">.</span><span class="n">pseudovoigt</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]),</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>The composite signal is simply given by</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-rampy.rameau">
<span id="rampy-rameau-module"></span><h2>rampy.rameau module<a class="headerlink" href="#module-rampy.rameau" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.rameau.DG2017_calibrate">
<span class="sig-prename descclassname"><span class="pre">rampy.rameau.</span></span><span class="sig-name descname"><span class="pre">DG2017_calibrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictio</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.rameau.DG2017_calibrate" title="Link to this definition"></a></dt>
<dd><p>Fit a calibration by optimizing the K coefficient in the DG2017 method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dictio</strong> (<em>dictionary</em>) – dictionary with arrays named “feo”, “rws” and “water”.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>popt</strong> – The optimize a and b parameters of the equation K = a * [FeO wt%] + b.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.rameau.DG2017_predict">
<span class="sig-prename descclassname"><span class="pre">rampy.rameau.</span></span><span class="sig-name descname"><span class="pre">DG2017_predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictio</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.096</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.663</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.rameau.DG2017_predict" title="Link to this definition"></a></dt>
<dd><p>Calculate the K coefficient for the DG2017 method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dictio</strong> (<em>dict</em>) – a dictionary with ndarrays named “feo” and “rws”</p></li>
<li><p><strong>b</strong> (<em>a and</em>) – factors in the equation: K = a * [FeO wt%] + b; default values from Di Genova et al. (2017)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>H2O (wt %)</strong> – The water content of the glasses calculated as Rws * (a * [FeO wt%] + b)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.rameau.LL2012_calibrate">
<span class="sig-prename descclassname"><span class="pre">rampy.rameau.</span></span><span class="sig-name descname"><span class="pre">LL2012_calibrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictio</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.rameau.LL2012_calibrate" title="Link to this definition"></a></dt>
<dd><p>Fit a calibration line following equations (2) and (3) from Le Losq et al. (2012)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dictio</strong> – dictionary with arrays named “feo”, “rws” and “water”.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>A</strong> – The parameter in the equation (3) of Le Losq et al. (2012).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.rameau.LL2012_predict">
<span class="sig-prename descclassname"><span class="pre">rampy.rameau.</span></span><span class="sig-name descname"><span class="pre">LL2012_predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictio</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.007609</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.rameau.LL2012_predict" title="Link to this definition"></a></dt>
<dd><p>Predict the water content using the equation (3) from Le Losq et al. (2012)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dictio</strong> (<em>dict</em>) – a dictionary with ndarray named “rws”</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The glass water contents in wt%</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>H2O</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.rameau.fit_spectra">
<span class="sig-prename descclassname"><span class="pre">rampy.rameau.</span></span><span class="sig-name descname"><span class="pre">fit_spectra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_liste</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'LL2012'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\t'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./raw/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">514.532</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spline_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.rameau.fit_spectra" title="Link to this definition"></a></dt>
<dd><p>Calculate the ratios of water and silicate signals from Raman spectra</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_liste</strong> (<em>Pandas DataFrame</em>) – Contains the list of spectra, see provided file as an example</p></li>
<li><p><strong>method</strong> (<em>string</em>) – The used method. LL2012: Le Losq et al. (2012); DG2017: Di Genova et al. (2017). See references.</p></li>
<li><p><strong>delim</strong> (<em>string</em>) – File delimiter. Use ‘   ‘ for tabulated text or ‘,’ for comma separated text.</p></li>
<li><p><strong>path_in</strong> (<em>string</em>) – Path for the spectra</p></li>
<li><p><strong>laser</strong> (<em>float</em>) – Laser line wavelength in nm</p></li>
<li><p><strong>spline_coeff</strong> (<em>float</em>) – Smoothing coefficient for the spline baseline. An array of size len(data_liste) can be provided. Default = 0.001.</p></li>
<li><p><strong>poly_coeff</strong> (<em>int</em>) – Polynomial coefficient for the polynomial baseline function. Default = 3 (DG2017 method). Set to 2 for Behrens et al. (2006) method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – Common x axis.</p></li>
<li><p><strong>y_all</strong> (<em>ndarray</em>) – All raw spectra from data_liste in an array of length len(x) and with as many column as spectra.</p></li>
<li><p><strong>y_all_corr</strong> (<em>ndarray</em>) – All corrected spectra from data_liste in an array of length len(x) and with as many column as spectra.</p></li>
<li><p><strong>y_all_base</strong> (<em>ndarray</em>) – All baselines for spectra from data_liste in an array of length len(x) and with as many column as spectra.</p></li>
<li><p><strong>rws</strong> (<em>ndarray</em>) – The ratio of the water integrated intensity over that of silicate signals.</p></li>
<li><p><strong>rw</strong> (<em>ndarray</em>) – The integrated intensity of water signal.</p></li>
<li><p><strong>rs</strong> (<em>ndarray</em>) – The integrated intensity of silicate signals.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>IOError</strong> – If method is not set to LL2012 or DG2017.</p>
</dd>
</dl>
<p class="rubric">References</p>
<ol class="upperalpha simple" start="3">
<li><p>Le Losq, D. R. Neuville, R. Moretti, J. Roux, Determination of water content in silicate glasses using Raman spectrometry: Implications for the study of explosive volcanism. American Mineralogist. 97, 779–790 (2012).</p></li>
<li><p>Di Genova et al., Effect of iron and nanolites on Raman spectra of volcanic glasses: A reassessment of existing strategies to estimate the water content. Chemical Geology. 475, 76–86 (2017).</p></li>
</ol>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="rampy.rameau.rameau">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">rampy.rameau.</span></span><span class="sig-name descname"><span class="pre">rameau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_liste</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_spectra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./raw/'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.rameau.rameau" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>treat Raman spectra of glass to retrieve the glass water content</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_liste</strong> (<em>Pandas dataframe</em>) – A Pandas dataframe containing the data and various meta information.</p></li>
<li><p><strong>path_spectra</strong> (<em>string</em>) – Path for the spectra. Default = ‘./raw/’</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.x">
<span class="sig-name descname"><span class="pre">x</span></span><a class="headerlink" href="#rampy.rameau.rameau.x" title="Link to this definition"></a></dt>
<dd><p>a 1D array (Nx1) containing the common x axis (wavelength) of the spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.y">
<span class="sig-name descname"><span class="pre">y</span></span><a class="headerlink" href="#rampy.rameau.rameau.y" title="Link to this definition"></a></dt>
<dd><p>a NxM array (with M the number of spectra) containing the raw intensities of the spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.y_corr">
<span class="sig-name descname"><span class="pre">y_corr</span></span><a class="headerlink" href="#rampy.rameau.rameau.y_corr" title="Link to this definition"></a></dt>
<dd><p>a NxM array (with M the number of spectra) containing the corrected intensities of the spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.y_base">
<span class="sig-name descname"><span class="pre">y_base</span></span><a class="headerlink" href="#rampy.rameau.rameau.y_base" title="Link to this definition"></a></dt>
<dd><p>a NxM array (with M the number of spectra) containing the backgrounds of the spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.rws">
<span class="sig-name descname"><span class="pre">rws</span></span><a class="headerlink" href="#rampy.rameau.rameau.rws" title="Link to this definition"></a></dt>
<dd><p>a 1D array (Nx1) containing the ratio between the integrated intensities of the water and silicate signals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.rw">
<span class="sig-name descname"><span class="pre">rw</span></span><a class="headerlink" href="#rampy.rameau.rameau.rw" title="Link to this definition"></a></dt>
<dd><p>a 1D array (Nx1) containing the integrated intensities of the water signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.rs">
<span class="sig-name descname"><span class="pre">rs</span></span><a class="headerlink" href="#rampy.rameau.rameau.rs" title="Link to this definition"></a></dt>
<dd><p>a 1D array (Nx1) containing the integrated intensities of the silicate signals.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.water">
<span class="sig-name descname"><span class="pre">water</span></span><a class="headerlink" href="#rampy.rameau.rameau.water" title="Link to this definition"></a></dt>
<dd><p>the known glass water content provided in data_liste (set to 0 if predicting for unknowns)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.water_predicted">
<span class="sig-name descname"><span class="pre">water_predicted</span></span><a class="headerlink" href="#rampy.rameau.rameau.water_predicted" title="Link to this definition"></a></dt>
<dd><p>the predicted glass water content provided in data_liste (set to 0 if predicting for unknowns)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.p">
<span class="sig-name descname"><span class="pre">p</span></span><a class="headerlink" href="#rampy.rameau.rameau.p" title="Link to this definition"></a></dt>
<dd><p>calibration coefficient(s) of the LL2012 or DG2017 method</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="rampy.rameau.rameau.names">
<span class="sig-name descname"><span class="pre">names</span></span><a class="headerlink" href="#rampy.rameau.rameau.names" title="Link to this definition"></a></dt>
<dd><p>filenames indicated in the data_liste input</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas dataframe</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>Uses either the LL2012 method (Le Losq et al., 2012), the DG2017 method (Di Genova et al., 2017) or the external calibration method (Thomas et al., 2008). See references.</p>
<p>In the LL2012 method, a cubic spline is fitted to the regions of interest provided in self.data_liste (see example).
The spline is smoothed by the spline_coeff of the data_reduction method. The water content is calculated following eq. (3) of LL2012, with the A coefficient either provided or calculated by the method self.calibrate().</p>
<p>In the DG2017 method, a third-order polynomial is fitted to the spectra following the instructions of Di Genova et al. (2017).
The water content is calculated as wt% H2O = Rws * (a * [FeO wt%] + b) with a and b the coefficients either provided or calculated by the method self.calibrate().</p>
<p>In the external calibration method, a cross-multiplication is computed using a reference spectrum and the proportionality relation between the water content of the glass and the water peak area of its spectrum.</p>
<p class="rubric">References</p>
<p>LL2102: C. Le Losq, D. R. Neuville, R. Moretti, J. Roux, Determination of water content in silicate glasses using Raman spectrometry: Implications for the study of explosive volcanism. American Mineralogist. 97, 779–790 (2012).
DG2017: D. Di Genova et al., Effect of iron and nanolites on Raman spectra of volcanic glasses: A reassessment of existing strategies to estimate the water content. Chemical Geology. 475, 76–86 (2017).
External calibration: S.-M. Thomas, R. Thomas, P. Davidson, P. Reichart, M. Koch-Muller, G. Dollinger, Application of Raman Spectroscopy to Quantify Trace Water Concentrations in Glasses and Garnets. American Mineralogist 2008, 93 (10), 1550–1557.</p>
<dl class="py method">
<dt class="sig sig-object py" id="rampy.rameau.rameau.calibrate">
<span class="sig-name descname"><span class="pre">calibrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_calib</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'LL2012'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\t'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_calib</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./raw/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">488.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spline_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.rameau.rameau.calibrate" title="Link to this definition"></a></dt>
<dd><p>Fit a calibration by optimizing the K coefficient(s) on a chosen dataset of calibration spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<em>object</em>) – rameau object with treated spectra (see data_reduction method)</p></li>
<li><p><strong>data_calib</strong> (<em>Pandas dataframe</em>) – A Pandas dataframe containing the calibration data (same informations as self.data_liste but for calibration spectra).
If data_calib is not given, the calibration is performed on self.data_liste.</p></li>
<li><p><strong>method</strong> (<em>string</em>) – the method used for calibration; choose between “LL2012” or “DG2017”, default = “LL2012”.</p></li>
<li><p><strong>delim</strong> (<em>string</em>) – File delimiter. Use ‘       ‘ for tabulated text or ‘,’ for comma separated text. Default = ‘       ‘.</p></li>
<li><p><strong>path_calib</strong> (<em>string</em>) – Path for the calibration spectra. Default = ‘./raw/’.</p></li>
<li><p><strong>laser</strong> (<em>float</em>) – Laser line wavelength in nm of the calibration spectra. Default = 488.0.</p></li>
<li><p><strong>spline_coeff</strong> (<em>float</em>) – Smoothing coefficient for the spline baseline. An array of size len(data_liste) can be provided. Default = 0.005.</p></li>
<li><p><strong>poly_coeff</strong> (<em>int</em>) – Polynomial coefficient for the polynomial baseline function. Default = 3 (DG2017 method; set to 2 for Behrens et al. (2006) method).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>popt</strong> (<em>ndarray or float</em>) – The optimized parameter(s);
if method = “DG2017”, popt=np.array([a,b]), parameters of the equation K = a * [FeO wt%] + b.
if method = “LL2017”, popt = A (float), with A parameter in the equation (3) of Le Losq et al. (2012).</p></li>
<li><p><strong>self.x_calib</strong> (<em>ndarray</em>) – Common x axis.</p></li>
<li><p><strong>self.y_calib</strong> (<em>ndarray</em>) – All raw calibration spectra from data_calib in an array of length len(x) and with as many column as spectra.</p></li>
<li><p><strong>self.y_corr_calib</strong> (<em>ndarray</em>) – All corrected calibration spectra from data_calib in an array of length len(x) and with as many column as spectra.</p></li>
<li><p><strong>self.y_base_calib</strong> (<em>ndarray</em>) – All baselines for calibration spectra from data_calib in an array of length len(x) and with as many column as spectra.</p></li>
<li><p><strong>self.rws_calib</strong> (<em>ndarray</em>) – The ratio of the water integrated intensity over that of silicate signals for calibration spectra from data_calib.</p></li>
<li><p><strong>self.rw_calib</strong> (<em>ndarray</em>) – The integrated intensity of water signal for calibration spectra from data_calib.</p></li>
<li><p><strong>self.rs_calib</strong> (<em>ndarray</em>) – The integrated intensity of silicate signals for calibration spectra from data_calib.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.rameau.rameau.data_reduction">
<span class="sig-name descname"><span class="pre">data_reduction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'LL2012'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'\t'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">514.532</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spline_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.rameau.rameau.data_reduction" title="Link to this definition"></a></dt>
<dd><p>process Raman spectra of glass to calculate the Rws ratio</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<em>object</em>) – a rameau object that has been initiated.</p></li>
<li><p><strong>method</strong> (<em>string</em>) – The used method. LL2012: Le Losq et al. (2012); DG2017: Di Genova et al. (2017). See references. Default = “LL2012”.</p></li>
<li><p><strong>delim</strong> (<em>string</em>) – File delimiter. Use ‘       ‘ for tabulated text or ‘,’ for comma separated text. Default = ‘       ‘.</p></li>
<li><p><strong>laser</strong> (<em>float</em>) – Laser line wavelength in nm. Default = 514.532.</p></li>
<li><p><strong>spline_coeff</strong> (<em>float</em>) – Smoothing coefficient for the spline baseline. An array of size len(data_liste) can be provided. Default = 0.001.</p></li>
<li><p><strong>poly_coeff</strong> (<em>int</em>) – Polynomial coefficient for the polynomial baseline function. Default = 3 (DG2017 method; set to 2 for Behrens et al. (2006) method).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>self.x</strong> (<em>ndarray</em>) – Common x axis.</p></li>
<li><p><strong>self.y_all</strong> (<em>ndarray</em>) – All raw spectra from data_liste in an array of length len(x) and with as many column as spectra.</p></li>
<li><p><strong>self.y_all_corr</strong> (<em>ndarray</em>) – All corrected spectra from data_liste in an array of length len(x) and with as many column as spectra.</p></li>
<li><p><strong>self.y_all_base</strong> (<em>ndarray</em>) – All baselines for spectra from data_liste in an array of length len(x) and with as many column as spectra.</p></li>
<li><p><strong>self.rws</strong> (<em>ndarray</em>) – The ratio of the water integrated intensity over that of silicate signals.</p></li>
<li><p><strong>self.rw</strong> (<em>ndarray</em>) – The integrated intensity of water signal.</p></li>
<li><p><strong>self.rs</strong> (<em>ndarray</em>) – The integrated intensity of silicate signals.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.rameau.rameau.external_calibration">
<span class="sig-name descname"><span class="pre">external_calibration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./raw/Standards/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([[2900,</span> <span class="pre">3100],</span> <span class="pre">[3700,</span> <span class="pre">3800]])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3750</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.rameau.rameau.external_calibration" title="Link to this definition"></a></dt>
<dd><p>Predict water content using an external calibration and reference spectra.
For this method, each spectrum from self.data_liste must have a reference spectrum with a known water concentration (filled in columns “Ref” and “Water Ref” respectively).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<em>object</em>) – a rameau object that has been initiated.</p></li>
<li><p><strong>path_ref</strong> (<em>string</em>) – Path for reference spectra.</p></li>
<li><p><strong>roi</strong> (<em>array</em><em>(</em><em>(</em><em>2</em><em>,</em><em>2</em><em>)</em><em>)</em>) – Region of interest at the beginning and the end of the water peak to fit the baseline.</p></li>
<li><p><strong>lb</strong> (<em>int</em>) – Lower limit for the water peak area calculation.</p></li>
<li><p><strong>hb</strong> (<em>int</em>) – Upper limit for the water peak area calculation.</p></li>
<li><p><strong>show_fig</strong> (<em>boolean</em>) – to show figures of water peak and baseline for each spectrum from self.data_list and its reference spectrum.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>wat_list</strong> (<em>ndarray</em>) – Array containing predicted water for spectra from self.data_liste.</p></li>
<li><p><strong>areas_list</strong> (<em>ndarray</em>) – Array containing water peak area for spectra from self.data_liste.</p></li>
<li><p><strong>areas_lref</strong> (<em>ndarray</em>) – Array containing water peak area for reference spectra.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">names</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[]</span></em><a class="headerlink" href="#id0" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id3">
<span class="sig-name descname"><span class="pre">p</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#id3" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="rampy.rameau.rameau.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'LL2012'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.rameau.rameau.predict" title="Link to this definition"></a></dt>
<dd><p>predict the water content from the Rws</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<em>object</em>) – rameau object with treated spectra (see data_reduction method).</p></li>
<li><p><strong>method</strong> (<em>string</em>) – the method used; choose between “LL2012” or “DG2017”, default = “LL2012”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>H2O</strong> – The glass water contents in wt%</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id4">
<span class="sig-name descname"><span class="pre">rs</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[]</span></em><a class="headerlink" href="#id4" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id5">
<span class="sig-name descname"><span class="pre">rw</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[]</span></em><a class="headerlink" href="#id5" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id6">
<span class="sig-name descname"><span class="pre">rws</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[]</span></em><a class="headerlink" href="#id6" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id7">
<span class="sig-name descname"><span class="pre">water</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[]</span></em><a class="headerlink" href="#id7" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id8">
<span class="sig-name descname"><span class="pre">water_predicted</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[]</span></em><a class="headerlink" href="#id8" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id9">
<span class="sig-name descname"><span class="pre">x</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[]</span></em><a class="headerlink" href="#id9" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id10">
<span class="sig-name descname"><span class="pre">y</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[]</span></em><a class="headerlink" href="#id10" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id11">
<span class="sig-name descname"><span class="pre">y_base</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[]</span></em><a class="headerlink" href="#id11" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id12">
<span class="sig-name descname"><span class="pre">y_corr</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[]</span></em><a class="headerlink" href="#id12" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-rampy.spectranization">
<span id="rampy-spectranization-module"></span><h2>rampy.spectranization module<a class="headerlink" href="#module-rampy.spectranization" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.centroid">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">centroid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.centroid" title="Link to this definition"></a></dt>
<dd><p>Calculates the centroid of y signal(s).</p>
<p>The centroid is calculated as (    ext{centroid} = sum(y / sum(y) cdot x) ).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – A 2D array of shape (m values, n samples) containing the x-axis values.</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em>) – A 2D array of shape (m values, n samples) containing the y-axis values.</p></li>
<li><p><strong>smoothing</strong> (<em>bool</em>) – Whether to smooth the signals before calculating centroids.
If True, smoothing is applied using <cite>rampy.smooth</cite> with additional arguments passed via <cite>kwargs</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 1D array of centroids for each sample in <cite>y</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">50.</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroids</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.convert_x_units">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">convert_x_units</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laser_nm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">532.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">way</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'nm_to_cm-1'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.convert_x_units" title="Link to this definition"></a></dt>
<dd><p>Converts between nanometers and inverse centimeters for Raman spectroscopy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – Array of x-axis values to convert.</p></li>
<li><p><strong>laser_nm</strong> (<em>float</em>) – Wavelength of the excitation laser in nanometers. Default is 532.0 nm.</p></li>
<li><p><strong>way</strong> (<em>str</em>) – Conversion direction. Options are:
- “nm_to_cm-1”: Convert from nanometers to inverse centimeters.
- “cm-1_to_nm”: Convert from inverse centimeters to nanometers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Converted x-axis values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If an invalid conversion direction is specified.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Convert from nanometers to inverse centimeters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">600.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_cm_1</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">convert_x_units</span><span class="p">(</span><span class="n">x_nm</span><span class="p">)</span>
</pre></div>
</div>
<p>Convert from inverse centimeters to nanometers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_cm_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1000.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_nm</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">convert_x_units</span><span class="p">(</span><span class="n">x_cm_1</span><span class="p">,</span> <span class="n">way</span><span class="o">=</span><span class="s2">&quot;cm-1_to_nm&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.despiking">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">despiking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neigh</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.despiking" title="Link to this definition"></a></dt>
<dd><p>Removes spikes from a 1D signal using a threshold-based approach.</p>
<p>This function identifies spikes in a signal by comparing local residuals to a threshold
based on the root mean square error (RMSE). Spikes are replaced with the mean of neighboring points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – A 1D array containing the x-axis values of the signal.</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em>) – A 1D array containing the y-axis values of the signal to despike.</p></li>
<li><p><strong>neigh</strong> (<em>int</em>) – The number of neighboring points to use for calculating average values
during despiking and for smoothing. Default is 4.</p></li>
<li><p><strong>threshold</strong> (<em>int</em>) – The multiplier of RMSE used to identify spikes. Default is 3.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 1D array of the despiked signal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">50.</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_despiked</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">despiking</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.flipsp">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">flipsp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.flipsp" title="Link to this definition"></a></dt>
<dd><p>Sorts or flips a spectrum along its row dimension based on x-axis values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sp</strong> (<em>np.ndarray</em>) – A 2D array where the first column contains x-axis values
and subsequent columns contain y-values.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The input array sorted in ascending order based on the first column.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Uses <cite>np.argsort</cite> to ensure sorting regardless of initial order.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">20</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_sp</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">flipsp</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.invcm_to_nm">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">invcm_to_nm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_inv_cm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laser_nm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">532.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.invcm_to_nm" title="Link to this definition"></a></dt>
<dd><p>Converts Raman shifts from inverse centimeters (cm⁻¹) to nanometers (nm).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_inv_cm</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Raman shift(s) in inverse centimeters (cm⁻¹).</p></li>
<li><p><strong>laser_nm</strong> (<em>float</em>) – Wavelength of the excitation laser in nanometers. Default is 532.0 nm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Wavelength(s) in nanometers corresponding to the Raman shifts.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float or np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_inv_cm</span> <span class="o">=</span> <span class="mf">1000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wavelength_nm</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">invcm_to_nm</span><span class="p">(</span><span class="n">x_inv_cm</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.nm_to_invcm">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">nm_to_invcm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">laser_nm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">532.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.nm_to_invcm" title="Link to this definition"></a></dt>
<dd><p>Converts wavelengths from nanometers (nm) to Raman shifts in inverse centimeters (cm⁻¹).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em><em> or </em><em>np.ndarray</em>) – Wavelength(s) in nanometers.</p></li>
<li><p><strong>laser_nm</strong> (<em>float</em>) – Wavelength of the excitation laser in nanometers. Default is 532.0 nm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Raman shift(s) in inverse centimeters (cm⁻¹).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float or np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wavelength_nm</span> <span class="o">=</span> <span class="mi">600</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shift_inv_cm</span> <span class="o">=</span> <span class="n">nm_to_invcm</span><span class="p">(</span><span class="n">wavelength_nm</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.normalise">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">normalise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'intensity'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.normalise" title="Link to this definition"></a></dt>
<dd><p>Normalizes the y signal(s) using specified methods.</p>
<p>This function normalizes the input y signal(s) based on the chosen method:
by area under the curve, maximum intensity, or min-max scaling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>np.ndarray</em>) – A 2D array of shape (m values, n samples) containing the y values to normalize.</p></li>
<li><p><strong>x</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – A 2D array of shape (m values, n samples) containing the x values
corresponding to <cite>y</cite>. Required for area normalization. Default is None.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – The normalization method to use. Options are:
- ‘area’: Normalize by the area under the curve.
- ‘intensity’: Normalize by the maximum intensity.
- ‘minmax’: Normalize using min-max scaling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D array of normalized y signals with the same shape as the input <cite>y</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If <cite>x</cite> is not provided when using the ‘area’ normalization method.</p></li>
<li><p><strong>NotImplementedError</strong> – If an invalid normalization method is specified.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">50.</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_norm</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.resample">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_new</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'extrapolate'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.resample" title="Link to this definition"></a></dt>
<dd><p>Resamples a y signal along new x-axis values using interpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – Original x-axis values.</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em>) – Original y-axis values corresponding to <cite>x</cite>.</p></li>
<li><p><strong>x_new</strong> (<em>np.ndarray</em>) – New x-axis values for resampling.</p></li>
<li><p><strong>fill_value</strong> (<em>array-like</em><em> or </em><em>(</em><em>array-like</em><em>, </em><em>array_like</em><em>) or </em><em>“extrapolate”</em><em>, </em><em>optional</em>) – behavior of the interpolation for requested points outside of the data range. See [scipy help for details](<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html</a>). Default is ‘“extrapolate”’.</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional arguments passed to <cite>scipy.interpolate.interp1d</cite>.</p>
<ul>
<li><p>kind (str or int): Type of interpolation (‘linear’, ‘cubic’, etc.). Default is ‘linear’.</p></li>
<li><p>bounds_error (bool): If True, a ValueError is raised any time interpolation is attempted on a value outside of the range of x (where extrapolation is necessary). If False, out of bounds values are assigned fill_value. By default, an error is raised unless fill_value=”extrapolate”.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Resampled y-values corresponding to <cite>x_new</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resampled_y</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">original_x</span><span class="p">,</span> <span class="n">original_y</span><span class="p">,</span> <span class="n">new_x</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.shiftsp">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">shiftsp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.shiftsp" title="Link to this definition"></a></dt>
<dd><p>Shifts the x-axis values of a spectrum by a given amount.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sp</strong> (<em>np.ndarray</em>) – A 2D array where the first column contains x-axis values
(e.g., frequency or wavenumber) and subsequent columns contain y-values.</p></li>
<li><p><strong>shift</strong> (<em>float</em>) – The amount by which to shift the x-axis values. Negative values
shift left; positive values shift right.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The input array with shifted x-axis values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">30</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shifted_sp</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">shiftsp</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.spectraoffset">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">spectraoffset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectre</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oft</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rampy.spectranization.spectraoffset" title="Link to this definition"></a></dt>
<dd><p>Applies vertical offsets to spectra.</p>
<p>This function offsets the y-values of each spectrum by a specified amount.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spectre</strong> (<em>np.ndarray</em>) – A 2D array where rows represent x-axis values
and columns represent spectra (first column is x-axis).</p></li>
<li><p><strong>oft</strong> (<em>np.ndarray</em>) – A 1D array specifying offset values for each spectrum.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D array with the same shape as <cite>spectre</cite>, where specified columns
have been vertically offset.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the length of <cite>oft</cite> does not match the number of spectra.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">30</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset_spectra</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">spectraoffset</span><span class="p">(</span><span class="n">spectre</span><span class="p">,</span> <span class="n">offsets</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.spectrarray">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">spectrarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sh</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.spectrarray" title="Link to this definition"></a></dt>
<dd><p>Constructs a unified array of spectra with a common x-axis.</p>
<p>This function reads spectral data from multiple files, resamples the y-values to match
a common x-axis, and combines them into a single array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>np.ndarray</em>) – Array of file names containing the spectra.</p></li>
<li><p><strong>sh</strong> (<em>int</em>) – Number of header lines to skip in each file.</p></li>
<li><p><strong>sf</strong> (<em>int</em>) – Number of footer lines to skip in each file.</p></li>
<li><p><strong>x</strong> (<em>np.ndarray</em>) – The common x-axis values to which all spectra will be resampled.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D array where the first column contains the common x-axis values
and subsequent columns contain the resampled y-values for each spectrum.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any file contains invalid or missing data.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses <cite>np.genfromtxt</cite> to read spectral data and <cite>resample</cite> for interpolation.</p></li>
<li><p>NaN values in the input data are automatically removed.</p></li>
</ul>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;spectrum1.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;spectrum2.txt&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectra_array</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">spectrarray</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">sh</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x_common</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rampy.spectranization.spectrataux">
<span class="sig-prename descclassname"><span class="pre">rampy.spectranization.</span></span><span class="sig-name descname"><span class="pre">spectrataux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectres</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#rampy.spectranization.spectrataux" title="Link to this definition"></a></dt>
<dd><p>Calculates the rate of change for each frequency in a set of spectra.</p>
<p>This function fits a second-order polynomial to the y-values at each frequency across
multiple spectra and calculates the polynomial coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>spectres</strong> (<em>np.ndarray</em>) – A 2D array where the first column contains the common x-axis
(frequencies) and subsequent columns contain y-values for multiple spectra.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D array where the first column contains the frequencies and subsequent
columns contain the polynomial coefficients for each frequency.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If curve fitting fails or input data is invalid.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">rampy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">32</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">taux</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">spectrataux</span><span class="p">(</span><span class="n">spectres</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-rampy.tlcorrection">
<span id="rampy-tlcorrection-module"></span><h2>rampy.tlcorrection module<a class="headerlink" href="#module-rampy.tlcorrection" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="rampy.tlcorrection.tlcorrection">
<span class="sig-prename descclassname"><span class="pre">rampy.tlcorrection.</span></span><span class="sig-name descname"><span class="pre">tlcorrection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelength</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#rampy.tlcorrection.tlcorrection" title="Link to this definition"></a></dt>
<dd><p>Corrects Raman spectra for temperature and excitation line effects.</p>
<p>This function applies corrections to Raman spectra to account for temperature and laser
excitation wavelength effects. It supports multiple correction equations and normalization
methods, making it suitable for a variety of materials and experimental conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – Raman shifts in cm⁻¹.</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em>) – Intensity values (e.g., counts).</p></li>
<li><p><strong>temperature</strong> (<em>float</em>) – Temperature in °C.</p></li>
<li><p><strong>wavelength</strong> (<em>float</em>) – Wavelength of the laser that excited the sample, in nm.</p></li>
<li><p><strong>correction</strong> (<em>str</em><em>, </em><em>optional</em>) – The correction equation to use. Options are:
- ‘long’: Default equation from Galeener and Sen (1978) with a (v_0^3) coefficient correction.
- ‘galeener’: Original equation from Galeener and Sen (1978), based on Shuker and Gammon (1970).
- ‘hehlen’: Equation from Hehlen et al. (2010), preserving the Boson peak signal. Default is ‘long’.</p></li>
<li><p><strong>normalisation</strong> (<em>str</em><em>, </em><em>optional</em>) – Normalization method for the corrected data. Options are:
- ‘intensity’: Normalize by maximum intensity.
- ‘area’: Normalize by total area under the curve.
- ‘no’: No normalization. Default is ‘area’.</p></li>
<li><p><strong>density</strong> (<em>float</em><em>, </em><em>optional</em>) – Density of the studied material in kg/m³, used only with the ‘hehlen’ equation.
Default is 2210.0 (density of silica).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><cite>x</cite> (np.ndarray): Raman shift values after correction.</p></li>
<li><p><cite>ycorr</cite> (np.ndarray): Corrected intensity values.</p></li>
<li><p><cite>ese_corr</cite> (np.ndarray): Propagated errors calculated as (sqrt{y}) on raw intensities.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[np.ndarray, np.ndarray, np.ndarray]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If an invalid correction or normalization method is specified.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The ‘galeener’ equation is a modification of Shuker and Gammon’s formula to account for
((v_0 - v)^4) dependence of Raman intensity.</p></li>
<li><p>The ‘long’ equation includes a (v_0^3) coefficient to remove cubic meter dimensions,
as used in several studies like Mysen et al. (1982).</p></li>
<li><p>The ‘hehlen’ equation avoids signal suppression below 500 cm⁻¹, preserving features like
the Boson peak in glasses.</p></li>
</ul>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Galeener, F.L., &amp; Sen, P.N. (1978). Theory of the first-order vibrational spectra of disordered solids. <em>Physical Review B</em>, 17(4), 1928–1933.</p></li>
<li><p>Hehlen, B. (2010). Inter-tetrahedra bond angle of permanently densified silicas extracted from their Raman spectra. <em>Journal of Physics: Condensed Matter</em>, 22(2), 025401.</p></li>
<li><p>Brooker, M.H., Nielsen, O.F., &amp; Praestgaard, E. (1988). Assessment of correction procedures for reduction of Raman spectra. <em>Journal of Raman Spectroscopy</em>, 19(2), 71–78.</p></li>
<li><p>Mysen, B.O., Finger, L.W., Virgo, D., &amp; Seifert, F.A. (1982). Curve-fitting of Raman spectra of silicate glasses. <em>American Mineralogist</em>, 67(7-8), 686–695.</p></li>
<li><p>Neuville, D.R., &amp; Mysen, B.O. (1996). Role of aluminium in the silicate network: In situ high-temperature study of glasses and melts on the join SiO₂-NaAlO₂. <em>Geochimica et Cosmochimica Acta</em>, 60(9), 1727–1737.</p></li>
<li><p>Le Losq, C., Neuville, D.R., Moretti, R., &amp; Roux, J. (2012). Determination of water content in silicate glasses using Raman spectrometry: Implications for the study of explosive volcanism. <em>American Mineralogist</em>, 97(5-6), 779–790.</p></li>
<li><p>Shuker, R., &amp; Gammon, R.W. (1970). Raman-scattering selection-rule breaking and the density of states in amorphous materials. <em>Physical Review Letters</em>, 25(4), 222.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Correct a simple spectrum using default parameters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">])</span>  <span class="c1"># Raman shifts in cm⁻¹</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>     <span class="c1"># Intensity values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature</span> <span class="o">=</span> <span class="mf">25.0</span>             <span class="c1"># Temperature in °C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wavelength</span> <span class="o">=</span> <span class="mf">532.0</span>             <span class="c1"># Wavelength in nm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_corr</span><span class="p">,</span> <span class="n">y_corr</span><span class="p">,</span> <span class="n">ese_corr</span> <span class="o">=</span> <span class="n">correct_spectra</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a specific correction equation and normalization method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_corr</span><span class="p">,</span> <span class="n">y_corr</span><span class="p">,</span> <span class="n">ese_corr</span> <span class="o">=</span> <span class="n">correct_spectra</span><span class="p">(</span>
<span class="go">        x=x,</span>
<span class="go">        y=y,</span>
<span class="go">        temperature=25,</span>
<span class="go">        wavelength=532,</span>
<span class="go">        correction=&#39;hehlen&#39;,</span>
<span class="go">        normalisation=&#39;intensity&#39;,</span>
<span class="go">        density=2500</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="utils.html" class="btn btn-neutral float-left" title="Utilities" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Charles Le Losq.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>